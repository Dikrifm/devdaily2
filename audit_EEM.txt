CODEIGNITER 4 - AUDIT LAPORAN (Entities)
============================================================
Tanggal: Wed Dec 17 10:57:03 WIB 2025
Proyek: /data/data/com.termux/files/home/devdaily2


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ENUMS                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Entities: 2

ğŸ“ ENUMS: app/Enums/ProductStatus.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Enums;

/**
 * Product Status Enumeration
 * 
 * Defines all possible states in the product workflow lifecycle.
 * Business Rule: Two-level verification process (input â†’ verify â†’ publish)
 * 
 * @package App\Enums
 */
enum ProductStatus: string
{
    /**
     * Initial state after admin input
     * Product data entered but not yet submitted for verification
     */
    case DRAFT = 'draft';

    /**
     * Submitted for verification by input admin
     * Awaiting second admin review and approval
     */
    case PENDING_VERIFICATION = 'pending_verification';

    /**
     * Verified by second admin
     * All data validated, ready for publishing
     */
    case VERIFIED = 'verified';

    /**
     * Live and visible to public users
     * Actively generating affiliate revenue
     */
    case PUBLISHED = 'published';

    /**
     * Soft-deleted or archived
     * Not visible, but kept for historical records
     */
    case ARCHIVED = 'archived';

    /**
     * Get all status values as array
     * Useful for validation and UI dropdowns
     * 
     * @return array
     */
    public static function all(): array
    {
        return array_column(self::cases(), 'value');
    }

    /**
     * Get statuses that are considered "active" in the system
     * Business Rule: Only PUBLISHED products are publicly visible
     * 
     * @return array
     */
    public static function activeStatuses(): array
    {
        return [self::PUBLISHED->value];
    }

    /**
     * Get statuses that require admin attention
     * Business Rule: PENDING_VERIFICATION needs second admin review
     * 
     * @return array
     */
    public static function pendingActionStatuses(): array
    {
        return [self::PENDING_VERIFICATION->value];
    }

    /**
     * Get statuses that allow editing
     * Business Rule: Can edit DRAFT and PENDING_VERIFICATION
     * 
     * @return array
     */
    public static function editableStatuses(): array
    {
        return [self::DRAFT->value, self::PENDING_VERIFICATION->value];
    }

    /**
     * Check if status allows publication
     * Business Rule: Only VERIFIED products can be published
     * 
     * @return bool
     */
    public function canBePublished(): bool
    {
        return in_array($this, [self::VERIFIED, self::PUBLISHED]);
    }

    /**
     * Check if status is considered "live"
     * Business Rule: PUBLISHED = visible to users
     * 
     * @return bool
     */
    public function isLive(): bool
    {
        return $this === self::PUBLISHED;
    }

    /**
     * Get next logical status in workflow
     * Business Rule: DRAFT â†’ PENDING â†’ VERIFIED â†’ PUBLISHED
     * 
     * @return ProductStatus|null
     */
    public function nextStatus(): ?ProductStatus
    {
        return match ($this) {
            self::DRAFT => self::PENDING_VERIFICATION,
            self::PENDING_VERIFICATION => self::VERIFIED,
            self::VERIFIED => self::PUBLISHED,
            self::PUBLISHED => self::ARCHIVED,
            self::ARCHIVED => null,
        };
    }

    /**
     * Get previous logical status in workflow
     * 
     * @return ProductStatus|null
     */
    public function previousStatus(): ?ProductStatus
    {
        return match ($this) {
            self::PENDING_VERIFICATION => self::DRAFT,
            self::VERIFIED => self::PENDING_VERIFICATION,
            self::PUBLISHED => self::VERIFIED,
            self::ARCHIVED => self::PUBLISHED,
            self::DRAFT => null,
        };
    }

    /**
     * Get display label for UI
     * 
     * @return string
     */
    public function label(): string
    {
        return match ($this) {
            self::DRAFT => 'Draft',
            self::PENDING_VERIFICATION => 'Pending Verification',
            self::VERIFIED => 'Verified',
            self::PUBLISHED => 'Published',
            self::ARCHIVED => 'Archived',
        };
    }

    /**
     * Get Tailwind CSS color class for status badges
     * 
     * @return string
     */
    public function colorClass(): string
    {
        return match ($this) {
            self::DRAFT => 'bg-gray-100 text-gray-800',
            self::PENDING_VERIFICATION => 'bg-yellow-100 text-yellow-800',
            self::VERIFIED => 'bg-blue-100 text-blue-800',
            self::PUBLISHED => 'bg-green-100 text-green-800',
            self::ARCHIVED => 'bg-red-100 text-red-800',
        };
    }

    /**
     * Get FontAwesome icon for status display
     * 
     * @return string
     */
    public function icon(): string
    {
        return match ($this) {
            self::DRAFT => 'fas fa-edit',
            self::PENDING_VERIFICATION => 'fas fa-clock',
            self::VERIFIED => 'fas fa-check-circle',
            self::PUBLISHED => 'fas fa-globe',
            self::ARCHIVED => 'fas fa-archive',
        };
    }

    /**
     * Validate if transition to target status is allowed
     * Business Rule: Strict workflow progression required
     * 
     * @param ProductStatus $targetStatus
     * @return bool
     */
    public function canTransitionTo(ProductStatus $targetStatus): bool
    {
        // Special case: can always archive from any state
        if ($targetStatus === self::ARCHIVED) {
            return true;
        }

        // Special case: can restore from archived to published
        if ($this === self::ARCHIVED && $targetStatus === self::PUBLISHED) {
            return true;
        }

        // Normal workflow progression
        $allowedTransitions = [
            self::DRAFT->value => [self::PENDING_VERIFICATION->value],
            self::PENDING_VERIFICATION->value => [self::VERIFIED->value, self::DRAFT->value],
            self::VERIFIED->value => [self::PUBLISHED->value, self::PENDING_VERIFICATION->value],
            self::PUBLISHED->value => [self::VERIFIED->value],
        ];

        return in_array(
            $targetStatus->value,
            $allowedTransitions[$this->value] ?? []
        );
    }

    /**
     * Get all allowed transitions from current status
     * 
     * @return array<ProductStatus>
     */
    public function allowedTransitions(): array
    {
        $transitions = [];

        foreach (self::cases() as $status) {
            if ($this->canTransitionTo($status)) {
                $transitions[] = $status;
            }
        }

        return $transitions;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENUMS: app/Enums/ImageSourceType.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Enums;

/**
 * Image Source Type Enumeration
 * 
 * Defines how product images are sourced in the system.
 * Business Rule: Manual curation allows both uploaded screenshots and external URLs.
 * 
 * @package App\Enums
 */
enum ImageSourceType: string
{
    /**
     * Image uploaded by admin via system
     * Stored locally in the server filesystem
     */
    case UPLOAD = 'upload';

    /**
     * Image referenced by external URL
     * Loaded directly from marketplace or CDN
     */
    case URL = 'url';

    /**
     * Get all source types as array
     * Useful for validation and form select options
     * 
     * @return array
     */
    public static function all(): array
    {
        return array_column(self::cases(), 'value');
    }

    /**
     * Check if this source type requires local file storage
     * 
     * @return bool
     */
    public function requiresLocalStorage(): bool
    {
        return $this === self::UPLOAD;
    }

    /**
     * Check if this source type requires URL validation
     * 
     * @return bool
     */
    public function requiresUrlValidation(): bool
    {
        return $this === self::URL;
    }

    /**
     * Get the storage path for uploaded images
     * 
     * @return string
     */
    public function getStoragePath(): string
    {
        return match ($this) {
            self::UPLOAD => 'uploads/products/',
            self::URL => '',
        };
    }

    /**
     * Get the maximum file size allowed for this source type
     * Returns in bytes for UPLOAD, null for URL
     * 
     * @return int|null
     */
    public function getMaxFileSize(): ?int
    {
        return match ($this) {
            self::UPLOAD => 5 * 1024 * 1024, // 5MB
            self::URL => null,
        };
    }

    /**
     * Get allowed file extensions for this source type
     * Returns array for UPLOAD, empty array for URL
     * 
     * @return array
     */
    public function getAllowedExtensions(): array
    {
        return match ($this) {
            self::UPLOAD => ['jpg', 'jpeg', 'png', 'webp'],
            self::URL => [],
        };
    }

    /**
     * Get validation rules for this source type
     * Useful for form validation in admin interface
     * 
     * @return array
     */
    public function getValidationRules(): array
    {
        return match ($this) {
            self::UPLOAD => [
                'max_size' => $this->getMaxFileSize(),
                'ext_in' => $this->getAllowedExtensions(),
                'is_image' => true,
            ],
            self::URL => [
                'valid_url' => true,
                'url_active' => true,
            ],
        };
    }

    /**
     * Get display label for UI
     * 
     * @return string
     */
    public function label(): string
    {
        return match ($this) {
            self::UPLOAD => 'Uploaded Image',
            self::URL => 'External URL',
        };
    }

    /**
     * Get description for UI tooltips
     * 
     * @return string
     */
    public function description(): string
    {
        return match ($this) {
            self::UPLOAD => 'Image uploaded directly to our servers. Recommended for screenshots.',
            self::URL => 'Image hosted externally (marketplace, CDN). Use for product photos.',
        };
    }

    /**
     * Get FontAwesome icon for display
     * 
     * @return string
     */
    public function icon(): string
    {
        return match ($this) {
            self::UPLOAD => 'fas fa-upload',
            self::URL => 'fas fa-link',
        };
    }

    /**
     * Get Tailwind CSS color class
     * 
     * @return string
     */
    public function colorClass(): string
    {
        return match ($this) {
            self::UPLOAD => 'bg-blue-100 text-blue-800',
            self::URL => 'bg-purple-100 text-purple-800',
        };
    }

    /**
     * Check if this source type is recommended for verification screenshots
     * Business Rule: Screenshot proof should be uploaded, not external URL
     * 
     * @return bool
     */
    public function isRecommendedForVerification(): bool
    {
        return $this === self::UPLOAD;
    }

    /**
     * Generate a filename pattern for uploaded images
     * 
     * @param string $productSlug
     * @param string $extension
     * @return string
     */
    public function generateFilename(string $productSlug, string $extension): string
    {
        if ($this !== self::UPLOAD) {
            throw new \LogicException('Filename generation only available for UPLOAD source type');
        }

        $timestamp = time();
        $hash = substr(md5($productSlug . $timestamp), 0, 8);
        
        return sprintf('%s-%s.%s', $productSlug, $hash, $extension);
    }

    /**
     * Get the full image path/URL for display
     * 
     * @param string $identifier Image path or URL
     * @return string
     */
    public function getDisplaySource(string $identifier): string
    {
        return match ($this) {
            self::UPLOAD => base_url($this->getStoragePath() . $identifier),
            self::URL => $identifier,
        };
    }

    /**
     * Validate an image source against this type's requirements
     * 
     * @param string $source
     * @return bool
     */
    public function validateSource(string $source): bool
    {
        return match ($this) {
            self::UPLOAD => file_exists(ROOTPATH . 'public/' . $this->getStoragePath() . $source),
            self::URL => filter_var($source, FILTER_VALIDATE_URL) !== false,
        };
    }

    /**
     * Get the recommended dimensions for this source type
     * 
     * @return array{width: int, height: int}
     */
    public function getRecommendedDimensions(): array
    {
        return match ($this) {
            self::UPLOAD => ['width' => 800, 'height' => 600],
            self::URL => ['width' => 1200, 'height' => 800],
        };
    }

    /**
     * Check if resizing is recommended for this source type
     * 
     * @return bool
     */
    public function shouldResize(): bool
    {
        return $this === self::UPLOAD;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ENTITIES                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Entities: 12

ğŸ“ ENTITIES: app/Entities/Admin.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Admin Entity
 * 
 * Represents an administrator in the system with authentication capabilities.
 * Core entity for admin management, authentication, and role-based access control.
 * 
 * @package App\Entities
 */
class Admin extends BaseEntity
{
    /**
     * Unique username for login
     * 
     * @var string
     */
    private string $username;

    /**
     * Email address (unique)
     * 
     * @var string
     */
    private string $email;

    /**
     * Hashed password (bcrypt)
     * 
     * @var string
     */
    private string $password_hash;

    /**
     * Admin's full name
     * 
     * @var string
     */
    private string $name;

    /**
     * Role: admin or super_admin
     * 
     * @var string
     */
    private string $role = 'admin';

    /**
     * Whether admin account is active
     * 
     * @var bool
     */
    private bool $active = true;

    /**
     * Last login timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $last_login = null;

    /**
     * Failed login attempts count
     * 
     * @var int
     */
    private int $login_attempts = 0;

    /**
     * Plain text password (temporary, not persisted)
     * 
     * @var string|null
     */
    private ?string $password = null;

    /**
     * Admin constructor
     * 
     * @param string $username
     * @param string $email
     * @param string $name
     */
    public function __construct(string $username, string $email, string $name)
    {
        $this->username = $username;
        $this->email = $email;
        $this->name = $name;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getUsername(): string
    {
        return $this->username;
    }

    public function getEmail(): string
    {
        return $this->email;
    }

    public function getPasswordHash(): string
    {
        return $this->password_hash;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getRole(): string
    {
        return $this->role;
    }

    public function isActive(): bool
    {
        return $this->active;
    }

    public function getLastLogin(): ?DateTimeImmutable
    {
        return $this->last_login;
    }

    public function getLoginAttempts(): int
    {
        return $this->login_attempts;
    }

    public function getPassword(): ?string
    {
        return $this->password;
    }

    // ==================== SETTER METHODS ====================

    public function setUsername(string $username): self
    {
        if ($this->username === $username) {
            return $this;
        }
        
        $this->trackChange('username', $this->username, $username);
        $this->username = $username;
        $this->markAsUpdated();
        return $this;
    }

    public function setEmail(string $email): self
    {
        if ($this->email === $email) {
            return $this;
        }
        
        $this->trackChange('email', $this->email, $email);
        $this->email = $email;
        $this->markAsUpdated();
        return $this;
    }

    public function setPasswordHash(string $password_hash): self
    {
        // Only track change if hash actually changes
        if ($this->password_hash !== $password_hash) {
            $this->trackChange('password_hash', '[HIDDEN]', '[HIDDEN]');
            $this->password_hash = $password_hash;
            $this->markAsUpdated();
        }
        return $this;
    }

    public function setName(string $name): self
    {
        if ($this->name === $name) {
            return $this;
        }
        
        $this->trackChange('name', $this->name, $name);
        $this->name = $name;
        $this->markAsUpdated();
        return $this;
    }

    public function setRole(string $role): self
    {
        if (!in_array($role, ['admin', 'super_admin'])) {
            throw new \InvalidArgumentException('Role must be either "admin" or "super_admin"');
        }
        
        if ($this->role === $role) {
            return $this;
        }
        
        $this->trackChange('role', $this->role, $role);
        $this->role = $role;
        $this->markAsUpdated();
        return $this;
    }

    public function setActive(bool $active): self
    {
        if ($this->active === $active) {
            return $this;
        }
        
        $this->trackChange('active', $this->active, $active);
        $this->active = $active;
        $this->markAsUpdated();
        return $this;
    }

    public function setLastLogin($last_login): self
    {
        if (is_string($last_login)) {
            $last_login = new DateTimeImmutable($last_login);
        }
        
        if ($last_login instanceof DateTimeImmutable) {
            if ($this->last_login && $this->last_login->format('Y-m-d H:i:s') === $last_login->format('Y-m-d H:i:s')) {
                return $this;
            }
            
            $oldValue = $this->last_login ? $this->last_login->format('Y-m-d H:i:s') : null;
            $newValue = $last_login->format('Y-m-d H:i:s');
            
            $this->trackChange('last_login', $oldValue, $newValue);
            $this->last_login = $last_login;
            // Don't mark as updated for login timestamps
        }
        
        return $this;
    }

    public function setLoginAttempts(int $login_attempts): self
    {
        if ($this->login_attempts === $login_attempts) {
            return $this;
        }
        
        $this->trackChange('login_attempts', $this->login_attempts, $login_attempts);
        $this->login_attempts = $login_attempts;
        // Don't mark as updated for login attempts
        return $this;
    }

    public function setPassword(?string $password): self
    {
        $this->password = $password;
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    /**
     * Check if admin is a super admin
     * 
     * @return bool
     */
    public function isSuperAdmin(): bool
    {
        return $this->role === 'super_admin';
    }

    /**
     * Check if admin is a regular admin
     * 
     * @return bool
     */
    public function isRegularAdmin(): bool
    {
        return $this->role === 'admin';
    }

    /**
     * Activate admin account
     * 
     * @return self
     */
    public function activate(): self
    {
        return $this->setActive(true);
    }

    /**
     * Deactivate admin account
     * 
     * @return self
     */
    public function deactivate(): self
    {
        return $this->setActive(false);
    }

    /**
     * Promote to super admin
     * 
     * @return self
     */
    public function promoteToSuperAdmin(): self
    {
        return $this->setRole('super_admin');
    }

    /**
     * Demote to regular admin
     * 
     * @return self
     */
    public function demoteToAdmin(): self
    {
        return $this->setRole('admin');
    }

    /**
     * Record successful login
     * 
     * @return self
     */
    public function recordLogin(): self
    {
        $this->setLastLogin(new DateTimeImmutable());
        $this->setLoginAttempts(0);
        return $this;
    }

    /**
     * Record failed login attempt
     * 
     * @return self
     */
    public function recordFailedLogin(): self
    {
        $this->setLoginAttempts($this->login_attempts + 1);
        return $this;
    }

    /**
     * Reset login attempts
     * 
     * @return self
     */
    public function resetLoginAttempts(): self
    {
        return $this->setLoginAttempts(0);
    }

    /**
     * Check if account is locked due to too many failed attempts
     * 
     * @param int $maxAttempts Maximum allowed attempts before lockout
     * @return bool
     */
    public function isLocked(int $maxAttempts = 5): bool
    {
        return $this->login_attempts >= $maxAttempts;
    }

    /**
     * Check if password needs rehash
     * 
     * @return bool
     */
    public function passwordNeedsRehash(): bool
    {
        return password_needs_rehash($this->password_hash, PASSWORD_BCRYPT, ['cost' => 12]);
    }

    /**
     * Verify password against stored hash
     * 
     * @param string $password
     * @return bool
     */
    public function verifyPassword(string $password): bool
    {
        return password_verify($password, $this->password_hash);
    }

    /**
     * Hash and set password
     * 
     * @param string $password
     * @param array $options Bcrypt options
     * @return self
     */
    public function setPasswordWithHash(string $password, array $options = ['cost' => 12]): self
    {
        $this->password = $password;
        $this->setPasswordHash(password_hash($password, PASSWORD_BCRYPT, $options));
        return $this;
    }

    /**
     * Check if admin can be archived
     * Business rule: Cannot archive own account, cannot archive last super admin
     * 
     * @param int $currentAdminId The ID of admin performing the action
     * @param int $superAdminCount Total number of active super admins
     * @return array{can: bool, reason: string}
     */
    public function canBeArchivedBy(int $currentAdminId, int $superAdminCount = 1): array
    {
        // Cannot archive self
        if ($this->getId() === $currentAdminId) {
            return ['can' => false, 'reason' => 'Cannot archive your own account'];
        }

        // Cannot archive if not active
        if (!$this->active) {
            return ['can' => false, 'reason' => 'Account is already deactivated'];
        }

        // If this is a super admin, check if it's the last one
        if ($this->isSuperAdmin() && $superAdminCount <= 1) {
            return ['can' => false, 'reason' => 'Cannot archive the last super admin'];
        }

        return ['can' => true, 'reason' => ''];
    }

    /**
     * Check if admin can be deleted
     * Business rule: Cannot delete own account, cannot delete last super admin
     * 
     * @param int $currentAdminId
     * @param int $superAdminCount
     * @return array{can: bool, reason: string}
     */
    public function canBeDeletedBy(int $currentAdminId, int $superAdminCount = 1): array
    {
        $archiveCheck = $this->canBeArchivedBy($currentAdminId, $superAdminCount);
        
        if (!$archiveCheck['can']) {
            return $archiveCheck;
        }

        // Additional checks for deletion (beyond archiving) could go here
        // For example: check if admin has created any content that needs reassignment

        return ['can' => true, 'reason' => ''];
    }

    /**
     * Get admin initials for avatar
     * 
     * @return string
     */
    public function getInitials(): string
    {
        $names = explode(' ', $this->name);
        $initials = '';
        
        foreach ($names as $name) {
            if (!empty($name)) {
                $initials .= strtoupper(substr($name, 0, 1));
                if (strlen($initials) >= 2) {
                    break;
                }
            }
        }
        
        return $initials ?: strtoupper(substr($this->username, 0, 2));
    }

    /**
     * Get Tailwind CSS color class based on role
     * 
     * @return string
     */
    public function getRoleColorClass(): string
    {
        return $this->isSuperAdmin() 
            ? 'bg-purple-100 text-purple-800' 
            : 'bg-blue-100 text-blue-800';
    }

    /**
     * Get role display label
     * 
     * @return string
     */
    public function getRoleLabel(): string
    {
        return $this->isSuperAdmin() ? 'Super Admin' : 'Admin';
    }

    /**
     * Get status display label
     * 
     * @return string
     */
    public function getStatusLabel(): string
    {
        return $this->active ? 'Active' : 'Inactive';
    }

    /**
     * Get status color class
     * 
     * @return string
     */
    public function getStatusColorClass(): string
    {
        return $this->active 
            ? 'bg-green-100 text-green-800' 
            : 'bg-red-100 text-red-800';
    }

    /**
     * Format last login for display
     * 
     * @return string
     */
    public function getFormattedLastLogin(): string
    {
        if (!$this->last_login) {
            return 'Never logged in';
        }
        
        $now = new DateTimeImmutable();
        $diff = $now->diff($this->last_login);
        
        if ($diff->days > 30) {
            return $this->last_login->format('Y-m-d');
        } elseif ($diff->days > 0) {
            return $diff->days . ' day' . ($diff->days > 1 ? 's' : '') . ' ago';
        } elseif ($diff->h > 0) {
            return $diff->h . ' hour' . ($diff->h > 1 ? 's' : '') . ' ago';
        } elseif ($diff->i > 0) {
            return $diff->i . ' minute' . ($diff->i > 1 ? 's' : '') . ' ago';
        } else {
            return 'Just now';
        }
    }

    /**
     * Check if admin has logged in recently (within 24 hours)
     * 
     * @return bool
     */
    public function isRecentlyActive(): bool
    {
        if (!$this->last_login) {
            return false;
        }
        
        $now = new DateTimeImmutable();
        $diff = $now->diff($this->last_login);
        
        return $diff->days === 0 && $diff->h < 24;
    }

    /**
     * Validate admin entity
     * Override parent validation with admin-specific rules
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $parentValidation = parent::validate();
        $errors = $parentValidation['errors'];
        
        // Admin-specific validation
        if (empty($this->username)) {
            $errors[] = 'Username cannot be empty';
        }
        
        if (!preg_match('/^[a-zA-Z0-9_]+$/', $this->username)) {
            $errors[] = 'Username can only contain letters, numbers, and underscores';
        }
        
        if (empty($this->email)) {
            $errors[] = 'Email cannot be empty';
        }
        
        if (!filter_var($this->email, FILTER_VALIDATE_EMAIL)) {
            $errors[] = 'Email address is not valid';
        }
        
        if (empty($this->name)) {
            $errors[] = 'Name cannot be empty';
        }
        
        if (strlen($this->name) > 100) {
            $errors[] = 'Name cannot exceed 100 characters';
        }
        
        if (!in_array($this->role, ['admin', 'super_admin'])) {
            $errors[] = 'Role must be either admin or super_admin';
        }
        
        // Password validation (only if password is set)
        if ($this->password !== null) {
            if (strlen($this->password) < 8) {
                $errors[] = 'Password must be at least 8 characters long';
            }
            
            if (!preg_match('/[A-Z]/', $this->password)) {
                $errors[] = 'Password must contain at least one uppercase letter';
            }
            
            if (!preg_match('/[a-z]/', $this->password)) {
                $errors[] = 'Password must contain at least one lowercase letter';
            }
            
            if (!preg_match('/[0-9]/', $this->password)) {
                $errors[] = 'Password must contain at least one number';
            }
        }
        
        // Password hash validation (if set)
        if (!empty($this->password_hash) && !password_get_info($this->password_hash)) {
            $errors[] = 'Password hash is not valid';
        }
        
        if ($this->login_attempts < 0) {
            $errors[] = 'Login attempts cannot be negative';
        }
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    /**
     * Prepare for save with password hashing
     * 
     * @param bool $isUpdate
     * @return void
     */
    public function prepareForSave(bool $isUpdate = false): void
    {
        parent::prepareForSave($isUpdate);
        
        // Hash password if plain password is set
        if ($this->password !== null) {
            $this->setPasswordWithHash($this->password);
            $this->password = null; // Clear plain password after hashing
        }
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'username' => $this->getUsername(),
            'email' => $this->getEmail(),
            'name' => $this->getName(),
            'role' => $this->getRole(),
            'role_label' => $this->getRoleLabel(),
            'role_color_class' => $this->getRoleColorClass(),
            'active' => $this->isActive(),
            'status_label' => $this->getStatusLabel(),
            'status_color_class' => $this->getStatusColorClass(),
            'last_login' => $this->getLastLogin(),
            'formatted_last_login' => $this->getFormattedLastLogin(),
            'login_attempts' => $this->getLoginAttempts(),
            'is_super_admin' => $this->isSuperAdmin(),
            'is_regular_admin' => $this->isRegularAdmin(),
            'is_locked' => $this->isLocked(),
            'is_recently_active' => $this->isRecentlyActive(),
            'initials' => $this->getInitials(),
            'password_needs_rehash' => $this->passwordNeedsRehash(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
            'is_deleted' => $this->isDeleted(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $admin = new self(
            $data['username'] ?? '',
            $data['email'] ?? '',
            $data['name'] ?? ''
        );

        if (isset($data['id'])) {
            $admin->setId($data['id']);
        }

        if (isset($data['password_hash'])) {
            $admin->setPasswordHash($data['password_hash']);
        }

        if (isset($data['role'])) {
            $admin->setRole($data['role']);
        }

        if (isset($data['active'])) {
            $admin->setActive((bool) $data['active']);
        }

        if (isset($data['last_login'])) {
            $admin->setLastLogin($data['last_login']);
        }

        if (isset($data['login_attempts'])) {
            $admin->setLoginAttempts((int) $data['login_attempts']);
        }

        if (isset($data['password'])) {
            $admin->setPassword($data['password']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $admin->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $admin->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $admin->setDeletedAt($data['deleted_at']);
        }

        return $admin;
    }

    /**
     * Create system admin (super admin for initial setup)
     * 
     * @return static
     */
    public static function createSystemAdmin(): static
    {
        $admin = new self(
            'system',
            'system@devdaily.local',
            'System Administrator'
        );
        
        $admin->setRole('super_admin');
        $admin->setActive(true);
        $admin->setPasswordWithHash('SecureSystemPassword123!');
        
        return $admin;
    }

    /**
     * Create sample admin for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        $admin = new self(
            'johndoe',
            'john@example.com',
            'John Doe'
        );
        
        $admin->setRole('super_admin');
        $admin->setActive(true);
        $admin->setLastLogin(new DateTimeImmutable('-2 hours'));
        $admin->setLoginAttempts(0);
        $admin->setPasswordWithHash('Password123!');
        
        return $admin;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/AuditLog.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Audit Log Entity
 * 
 * Represents an immutable audit log entry for tracking all administrative actions.
 * This entity does NOT extend BaseEntity because audit logs have a different structure
 * and are immutable (cannot be updated or deleted).
 * 
 * @package App\Entities
 */
class AuditLog
{
    /**
     * Log entry ID
     * 
     * @var int|null
     */
    private ?int $id = null;

    /**
     * Admin who performed the action (nullable for system actions)
     * 
     * @var int|null
     */
    private ?int $admin_id = null;

    /**
     * Type of action performed
     * 
     * @var string
     */
    private string $action_type;

    /**
     * Type of entity affected
     * 
     * @var string
     */
    private string $entity_type;

    /**
     * ID of entity affected
     * 
     * @var int
     */
    private int $entity_id;

    /**
     * JSON snapshot of values before change
     * 
     * @var string|null
     */
    private ?string $old_values = null;

    /**
     * JSON snapshot of values after change
     * 
     * @var string|null
     */
    private ?string $new_values = null;

    /**
     * Human-readable summary of changes
     * 
     * @var string|null
     */
    private ?string $changes_summary = null;

    /**
     * IP address of the requester
     * 
     * @var string|null
     */
    private ?string $ip_address = null;

    /**
     * User agent string of the requester
     * 
     * @var string|null
     */
    private ?string $user_agent = null;

    /**
     * When the action was performed
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $performed_at = null;

    /**
     * Admin name (joined from admins table, not part of database)
     * 
     * @var string|null
     */
    private ?string $admin_name = null;

    /**
     * Admin username (joined from admins table, not part of database)
     * 
     * @var string|null
     */
    private ?string $admin_username = null;

    /**
     * AuditLog constructor
     * 
     * @param string $action_type
     * @param string $entity_type
     * @param int $entity_id
     */
    public function __construct(string $action_type, string $entity_type, int $entity_id)
    {
        $this->action_type = $action_type;
        $this->entity_type = $entity_type;
        $this->entity_id = $entity_id;
        $this->performed_at = new DateTimeImmutable();
    }

    // ==================== GETTER METHODS ====================

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getAdminId(): ?int
    {
        return $this->admin_id;
    }

    public function getActionType(): string
    {
        return $this->action_type;
    }

    public function getEntityType(): string
    {
        return $this->entity_type;
    }

    public function getEntityId(): int
    {
        return $this->entity_id;
    }

    public function getOldValues(): ?string
    {
        return $this->old_values;
    }

    public function getNewValues(): ?string
    {
        return $this->new_values;
    }

    public function getChangesSummary(): ?string
    {
        return $this->changes_summary;
    }

    public function getIpAddress(): ?string
    {
        return $this->ip_address;
    }

    public function getUserAgent(): ?string
    {
        return $this->user_agent;
    }

    public function getPerformedAt(): ?DateTimeImmutable
    {
        return $this->performed_at;
    }

    public function getAdminName(): ?string
    {
        return $this->admin_name;
    }

    public function getAdminUsername(): ?string
    {
        return $this->admin_username;
    }

    // ==================== SETTER METHODS ====================

    public function setId(?int $id): self
    {
        $this->id = $id;
        return $this;
    }

    public function setAdminId(?int $admin_id): self
    {
        $this->admin_id = $admin_id;
        return $this;
    }

    public function setActionType(string $action_type): self
    {
        $this->action_type = $action_type;
        return $this;
    }

    public function setEntityType(string $entity_type): self
    {
        $this->entity_type = $entity_type;
        return $this;
    }

    public function setEntityId(int $entity_id): self
    {
        $this->entity_id = $entity_id;
        return $this;
    }

    public function setOldValues(?string $old_values): self
    {
        $this->old_values = $old_values;
        return $this;
    }

    public function setNewValues(?string $new_values): self
    {
        $this->new_values = $new_values;
        return $this;
    }

    public function setChangesSummary(?string $changes_summary): self
    {
        $this->changes_summary = $changes_summary;
        return $this;
    }

    public function setIpAddress(?string $ip_address): self
    {
        $this->ip_address = $ip_address;
        return $this;
    }

    public function setUserAgent(?string $user_agent): self
    {
        $this->user_agent = $user_agent;
        return $this;
    }

    public function setPerformedAt($performed_at): self
    {
        if (is_string($performed_at)) {
            $this->performed_at = new DateTimeImmutable($performed_at);
        } elseif ($performed_at instanceof DateTimeImmutable) {
            $this->performed_at = $performed_at;
        } else {
            $this->performed_at = null;
        }
        return $this;
    }

    public function setAdminName(?string $admin_name): self
    {
        $this->admin_name = $admin_name;
        return $this;
    }

    public function setAdminUsername(?string $admin_username): self
    {
        $this->admin_username = $admin_username;
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    /**
     * Check if this log entry has old values
     * 
     * @return bool
     */
    public function hasOldValues(): bool
    {
        return !empty($this->old_values);
    }

    /**
     * Check if this log entry has new values
     * 
     * @return bool
     */
    public function hasNewValues(): bool
    {
        return !empty($this->new_values);
    }

    /**
     * Get old values as array
     * 
     * @return array|null
     */
    public function getOldValuesArray(): ?array
    {
        if (!$this->hasOldValues()) {
            return null;
        }

        return json_decode($this->old_values, true);
    }

    /**
     * Get new values as array
     * 
     * @return array|null
     */
    public function getNewValuesArray(): ?array
    {
        if (!$this->hasNewValues()) {
            return null;
        }

        return json_decode($this->new_values, true);
    }

    /**
     * Check if this log was performed by a specific admin
     * 
     * @param int $adminId
     * @return bool
     */
    public function wasPerformedBy(int $adminId): bool
    {
        return $this->admin_id === $adminId;
    }

    /**
     * Check if this log was performed by the system (no admin)
     * 
     * @return bool
     */
    public function wasSystemAction(): bool
    {
        return $this->admin_id === null;
    }

    /**
     * Get formatted performed at date
     * 
     * @param string $format
     * @return string
     */
    public function getFormattedPerformedAt(string $format = 'Y-m-d H:i:s'): string
    {
        return $this->performed_at ? $this->performed_at->format($format) : '';
    }

    /**
     * Get human-readable action type
     * 
     * @return string
     */
    public function getActionTypeLabel(): string
    {
        $labels = [
            'create'              => 'Create',
            'update'              => 'Update',
            'delete'              => 'Delete',
            'verify'              => 'Verify',
            'publish'             => 'Publish',
            'archive'             => 'Archive',
            'restore'             => 'Restore',
            'login'               => 'Login',
            'logout'              => 'Logout',
            'password_change'     => 'Password Change',
            'role_change'         => 'Role Change',
            'status_change'       => 'Status Change',
            'bulk_operation'      => 'Bulk Operation',
            'import'              => 'Import',
            'export'              => 'Export',
            'system'              => 'System Action'
        ];

        return $labels[$this->action_type] ?? ucfirst(str_replace('_', ' ', $this->action_type));
    }

    /**
     * Get action icon based on action type
     * 
     * @return string
     */
    public function getActionIcon(): string
    {
        $icons = [
            'create'          => 'fas fa-plus-circle',
            'update'          => 'fas fa-edit',
            'delete'          => 'fas fa-trash',
            'verify'          => 'fas fa-check-circle',
            'publish'         => 'fas fa-globe',
            'archive'         => 'fas fa-archive',
            'restore'         => 'fas fa-undo',
            'login'           => 'fas fa-sign-in-alt',
            'logout'          => 'fas fa-sign-out-alt',
            'password_change' => 'fas fa-key',
            'role_change'     => 'fas fa-user-tag',
            'status_change'   => 'fas fa-exchange-alt',
            'bulk_operation'  => 'fas fa-layer-group',
            'import'          => 'fas fa-file-import',
            'export'          => 'fas fa-file-export',
            'system'          => 'fas fa-robot'
        ];

        return $icons[$this->action_type] ?? 'fas fa-history';
    }

    /**
     * Get Tailwind CSS color class based on action type
     * 
     * @return string
     */
    public function getActionColorClass(): string
    {
        $colors = [
            'create'          => 'bg-blue-100 text-blue-800',
            'update'          => 'bg-yellow-100 text-yellow-800',
            'delete'          => 'bg-red-100 text-red-800',
            'verify'          => 'bg-green-100 text-green-800',
            'publish'         => 'bg-purple-100 text-purple-800',
            'archive'         => 'bg-gray-100 text-gray-800',
            'restore'         => 'bg-indigo-100 text-indigo-800',
            'login'           => 'bg-emerald-100 text-emerald-800',
            'logout'          => 'bg-orange-100 text-orange-800',
            'password_change' => 'bg-cyan-100 text-cyan-800',
            'role_change'     => 'bg-pink-100 text-pink-800',
            'status_change'   => 'bg-teal-100 text-teal-800',
            'bulk_operation'  => 'bg-amber-100 text-amber-800',
            'import'          => 'bg-lime-100 text-lime-800',
            'export'          => 'bg-fuchsia-100 text-fuchsia-800',
            'system'          => 'bg-slate-100 text-slate-800'
        ];

        return $colors[$this->action_type] ?? 'bg-gray-100 text-gray-800';
    }

    /**
     * Get admin display name (falls back to username or "System")
     * 
     * @return string
     */
    public function getAdminDisplayName(): string
    {
        if ($this->admin_name) {
            return $this->admin_name;
        }

        if ($this->admin_username) {
            return $this->admin_username;
        }

        return $this->wasSystemAction() ? 'System' : 'Unknown Admin';
    }

    /**
     * Get time elapsed since performed at
     * 
     * @return string
     */
    public function getTimeAgo(): string
    {
        if (!$this->performed_at) {
            return 'Unknown time';
        }

        $now = new DateTimeImmutable();
        $diff = $now->diff($this->performed_at);

        if ($diff->y > 0) {
            return $diff->y . ' year' . ($diff->y > 1 ? 's' : '') . ' ago';
        }

        if ($diff->m > 0) {
            return $diff->m . ' month' . ($diff->m > 1 ? 's' : '') . ' ago';
        }

        if ($diff->d > 0) {
            return $diff->d . ' day' . ($diff->d > 1 ? 's' : '') . ' ago';
        }

        if ($diff->h > 0) {
            return $diff->h . ' hour' . ($diff->h > 1 ? 's' : '') . ' ago';
        }

        if ($diff->i > 0) {
            return $diff->i . ' minute' . ($diff->i > 1 ? 's' : '') . ' ago';
        }

        return 'Just now';
    }

    /**
     * Check if this log is recent (within last 24 hours)
     * 
     * @return bool
     */
    public function isRecent(): bool
    {
        if (!$this->performed_at) {
            return false;
        }

        $now = new DateTimeImmutable();
        $diff = $now->diff($this->performed_at);

        return $diff->days === 0 && $diff->h < 24;
    }

    /**
     * Get entity reference string
     * 
     * @return string
     */
    public function getEntityReference(): string
    {
        return $this->entity_type . ' #' . $this->entity_id;
    }

    /**
     * Check if changes summary contains specific text
     * 
     * @param string $search
     * @return bool
     */
    public function summaryContains(string $search): bool
    {
        if (!$this->changes_summary) {
            return false;
        }

        return stripos($this->changes_summary, $search) !== false;
    }

    /**
     * Get truncated changes summary for display
     * 
     * @param int $length
     * @return string
     */
    public function getTruncatedSummary(int $length = 100): string
    {
        if (!$this->changes_summary) {
            return '';
        }

        if (strlen($this->changes_summary) <= $length) {
            return $this->changes_summary;
        }

        return substr($this->changes_summary, 0, $length - 3) . '...';
    }

    // ==================== VALIDATION METHODS ====================

    /**
     * Validate audit log data
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $errors = [];

        // Required fields
        if (empty($this->action_type)) {
            $errors[] = 'Action type is required';
        }

        if (empty($this->entity_type)) {
            $errors[] = 'Entity type is required';
        }

        if (empty($this->entity_id)) {
            $errors[] = 'Entity ID is required';
        }

        // Validate JSON fields
        if ($this->old_values && !$this->isValidJson($this->old_values)) {
            $errors[] = 'Old values must be valid JSON';
        }

        if ($this->new_values && !$this->isValidJson($this->new_values)) {
            $errors[] = 'New values must be valid JSON';
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    /**
     * Check if string is valid JSON
     * 
     * @param string $json
     * @return bool
     */
    private function isValidJson(string $json): bool
    {
        json_decode($json);
        return json_last_error() === JSON_ERROR_NONE;
    }

    // ==================== SERIALIZATION METHODS ====================

    /**
     * Convert entity to array representation
     * 
     * @return array
     */
    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'admin_id' => $this->getAdminId(),
            'action_type' => $this->getActionType(),
            'action_type_label' => $this->getActionTypeLabel(),
            'action_icon' => $this->getActionIcon(),
            'action_color_class' => $this->getActionColorClass(),
            'entity_type' => $this->getEntityType(),
            'entity_id' => $this->getEntityId(),
            'entity_reference' => $this->getEntityReference(),
            'old_values' => $this->getOldValues(),
            'old_values_array' => $this->getOldValuesArray(),
            'new_values' => $this->getNewValues(),
            'new_values_array' => $this->getNewValuesArray(),
            'changes_summary' => $this->getChangesSummary(),
            'truncated_summary' => $this->getTruncatedSummary(),
            'ip_address' => $this->getIpAddress(),
            'user_agent' => $this->getUserAgent(),
            'performed_at' => $this->getPerformedAt(),
            'formatted_performed_at' => $this->getFormattedPerformedAt(),
            'time_ago' => $this->getTimeAgo(),
            'admin_name' => $this->getAdminName(),
            'admin_username' => $this->getAdminUsername(),
            'admin_display_name' => $this->getAdminDisplayName(),
            'was_system_action' => $this->wasSystemAction(),
            'is_recent' => $this->isRecent(),
            'has_old_values' => $this->hasOldValues(),
            'has_new_values' => $this->hasNewValues(),
        ];
    }

    /**
     * Create entity from array data
     * 
     * @param array $data
     * @return static
     */
    public static function fromArray(array $data): static
    {
        $auditLog = new self(
            $data['action_type'] ?? '',
            $data['entity_type'] ?? '',
            $data['entity_id'] ?? 0
        );

        if (isset($data['id'])) {
            $auditLog->setId($data['id']);
        }

        if (isset($data['admin_id'])) {
            $auditLog->setAdminId($data['admin_id']);
        }

        if (isset($data['old_values'])) {
            $auditLog->setOldValues($data['old_values']);
        }

        if (isset($data['new_values'])) {
            $auditLog->setNewValues($data['new_values']);
        }

        if (isset($data['changes_summary'])) {
            $auditLog->setChangesSummary($data['changes_summary']);
        }

        if (isset($data['ip_address'])) {
            $auditLog->setIpAddress($data['ip_address']);
        }

        if (isset($data['user_agent'])) {
            $auditLog->setUserAgent($data['user_agent']);
        }

        if (isset($data['performed_at'])) {
            $auditLog->setPerformedAt($data['performed_at']);
        }

        if (isset($data['admin_name'])) {
            $auditLog->setAdminName($data['admin_name']);
        }

        if (isset($data['admin_username'])) {
            $auditLog->setAdminUsername($data['admin_username']);
        }

        return $auditLog;
    }

    /**
     * Create a sample audit log for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        $auditLog = new self('update', 'Product', 123);
        $auditLog->setAdminId(1);
        $auditLog->setAdminName('John Doe');
        $auditLog->setAdminUsername('johndoe');
        $auditLog->setChangesSummary('Updated product name from "Old Product" to "New Product"');
        $auditLog->setIpAddress('192.168.1.100');
        $auditLog->setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
        $auditLog->setPerformedAt(new DateTimeImmutable('2024-01-15 14:30:00'));
        
        return $auditLog;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/BaseEntity.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use App\Entities\Traits\TimestampableTrait;
use App\Entities\Traits\SoftDeletableTrait;
use DateTimeImmutable;

/**
 * Base Entity Abstract Class
 * 
 * Foundation for all domain entities in the system.
 * Provides common properties (id) and traits (timestampable, soft deletable).
 * Enhanced with state validation and change tracking for immutable patterns.
 * 
 * @package App\Entities
 */
abstract class BaseEntity
{
    use TimestampableTrait;
    use SoftDeletableTrait;

    /**
     * Primary key identifier
     * 
     * @var int|null
     */
    protected ?int $id = null;

    /**
     * Track changes for auditing purposes
     * 
     * @var array<string, array{old: mixed, new: mixed}>|null
     */
    private ?array $changes = null;

    /**
     * Get the entity's primary key
     * 
     * @return int|null
     */
    public function getId(): ?int
    {
        return $this->id;
    }

    /**
     * Set the entity's primary key
     * Should only be called by the repository/hydrator
     * 
     * @param int|null $id
     * @return void
     */
    public function setId(?int $id): void
    {
        $this->id = $id;
    }

    /**
     * Check if entity is new (not persisted)
     * 
     * @return bool
     */
    public function isNew(): bool
    {
        return $this->id === null;
    }

    /**
     * Check if entity exists in database
     * 
     * @return bool
     */
    public function exists(): bool
    {
        return $this->id !== null;
    }

    /**
     * Initialize entity with creation timestamps
     * Should be called when creating new entity
     * 
     * @return void
     */
    public function initialize(): void
    {
        if ($this->isNew()) {
            $this->initializeTimestamps();
        }
    }

    /**
     * Update entity's updated_at timestamp
     * 
     * @return void
     */
    public function markAsUpdated(): void
    {
        $this->touch();
    }

    /**
     * Track a property change for auditing
     * 
     * @param string $property
     * @param mixed $oldValue
     * @param mixed $newValue
     * @return void
     */
    protected function trackChange(string $property, mixed $oldValue, mixed $newValue): void
    {
        if ($oldValue === $newValue) {
            return;
        }

        if ($this->changes === null) {
            $this->changes = [];
        }

        $this->changes[$property] = [
            'old' => $oldValue,
            'new' => $newValue,
            'changed_at' => new DateTimeImmutable()
        ];
    }

    /**
     * Get all tracked changes since last reset
     * 
     * @return array<string, array{old: mixed, new: mixed, changed_at: DateTimeImmutable}>
     */
    public function getChanges(): array
    {
        return $this->changes ?? [];
    }

    /**
     * Check if entity has any tracked changes
     * 
     * @return bool
     */
    public function hasChanges(): bool
    {
        return !empty($this->changes);
    }

    /**
     * Clear tracked changes
     * Typically called after persisting to database
     * 
     * @return void
     */
    public function clearChanges(): void
    {
        $this->changes = null;
    }

    /**
     * Get a summary of changes for audit logging
     * 
     * @return array{count: int, properties: array<string>, summary: string}
     */
    public function getChangesSummary(): array
    {
        $changes = $this->getChanges();
        
        if (empty($changes)) {
            return [
                'count' => 0,
                'properties' => [],
                'summary' => 'No changes'
            ];
        }

        $properties = array_keys($changes);
        $summaryParts = [];

        foreach ($changes as $property => $change) {
            $old = $this->formatChangeValue($change['old']);
            $new = $this->formatChangeValue($change['new']);
            $summaryParts[] = sprintf('%s: %s â†’ %s', $property, $old, $new);
        }

        return [
            'count' => count($changes),
            'properties' => $properties,
            'summary' => implode('; ', $summaryParts)
        ];
    }

    /**
     * Format a value for change summary
     * 
     * @param mixed $value
     * @return string
     */
    private function formatChangeValue(mixed $value): string
    {
        if ($value === null) {
            return 'NULL';
        }

        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (is_object($value)) {
            if ($value instanceof DateTimeImmutable) {
                return $value->format('Y-m-d H:i:s');
            }
            
            if (method_exists($value, '__toString')) {
                return (string) $value;
            }
            
            return get_class($value);
        }

        if (is_array($value)) {
            return '[' . count($value) . ' items]';
        }

        $stringValue = (string) $value;
        
        // Truncate long values
        if (strlen($stringValue) > 50) {
            return substr($stringValue, 0, 47) . '...';
        }

        return $stringValue;
    }

    /**
     * Validate that a state transition is allowed
     * Generic method that can be overridden by child entities
     * 
     * @param string|object $currentState
     * @param string|object $newState
     * @param array $allowedTransitions Map of current state to array of allowed next states
     * @return bool
     */
    protected function validateStateTransition(
        string|object $currentState,
        string|object $newState,
        array $allowedTransitions
    ): bool {
        $current = is_object($currentState) ? $currentState->value : (string) $currentState;
        $new = is_object($newState) ? $newState->value : (string) $newState;

        if ($current === $new) {
            return true; // No change is always allowed
        }

        return in_array($new, $allowedTransitions[$current] ?? [], true);
    }

    /**
     * Prepare entity for database insertion/update
     * This method can be overridden by child entities
     * to add custom pre-save logic
     * 
     * @param bool $isUpdate Whether this is an update operation
     * @return void
     */
    public function prepareForSave(bool $isUpdate = false): void
    {
        if ($isUpdate) {
            $this->markAsUpdated();
        } else {
            $this->initialize();
        }
    }

    /**
     * Validate entity state before persistence
     * Override in child entities to add custom validation
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $errors = [];
        
        // Basic validation that applies to all entities
        if ($this->isDeleted() && $this->getDeletedAt() === null) {
            $errors[] = 'Deleted entity must have deletion timestamp';
        }
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    /**
     * Check if entity can be archived/soft-deleted
     * Override in child entities to add business rules
     * 
     * @return bool
     */
    public function canBeArchived(): bool
    {
        return !$this->isDeleted();
    }

    /**
     * Check if entity can be restored from archive
     * 
     * @return bool
     */
    public function canBeRestored(): bool
    {
        return $this->isDeleted();
    }

    /**
     * Get entity type for auditing purposes
     * 
     * @return string
     */
    public function getEntityType(): string
    {
        return basename(str_replace('\\', '/', static::class));
    }

    /**
     * Get entity identifier for auditing
     * Combines type and ID for unique identification
     * 
     * @return string
     */
    public function getAuditIdentifier(): string
    {
        return sprintf('%s#%s', $this->getEntityType(), $this->id ?? 'new');
    }

    /**
     * Create a snapshot of current state for auditing
     * 
     * @return array
     */
    public function createSnapshot(): array
    {
        return [
            'id' => $this->getId(),
            'type' => $this->getEntityType(),
            'data' => $this->toArray(),
            'timestamp' => new DateTimeImmutable(),
            'is_deleted' => $this->isDeleted(),
            'is_new' => $this->isNew()
        ];
    }

    /**
     * Compare with another entity of same type
     * 
     * @param BaseEntity $other
     * @return array{equal: bool, differences: array<string, array{self: mixed, other: mixed}>}
     */
    public function compareWith(BaseEntity $other): array
    {
        if (get_class($this) !== get_class($other)) {
            throw new \InvalidArgumentException('Cannot compare entities of different types');
        }

        $thisData = $this->toArray();
        $otherData = $other->toArray();
        
        $differences = [];
        
        foreach ($thisData as $key => $value) {
            if (!array_key_exists($key, $otherData) || $otherData[$key] != $value) {
                $differences[$key] = [
                    'self' => $value,
                    'other' => $otherData[$key] ?? null
                ];
            }
        }
        
        // Check for keys in other that aren't in this
        foreach ($otherData as $key => $value) {
            if (!array_key_exists($key, $thisData)) {
                $differences[$key] = [
                    'self' => null,
                    'other' => $value
                ];
            }
        }

        return [
            'equal' => empty($differences),
            'differences' => $differences
        ];
    }

    /**
     * Convert entity to array representation
     * Should be implemented by child entities
     * 
     * @return array
     */
    abstract public function toArray(): array;

    /**
     * Create entity from array data
     * Should be implemented as static factory in child entities
     * 
     * @param array $data
     * @return static
     */
    abstract public static function fromArray(array $data): static;
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Category.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Category Entity
 * 
 * Represents a product category in the system.
 * Limited to 15 categories as per business constraints.
 * 
 * @package App\Entities
 */
class Category extends BaseEntity
{
    /**
     * Category name
     * 
     * @var string
     */
    private string $name;

    /**
     * URL-friendly slug (unique)
     * 
     * @var string
     */
    private string $slug;

    /**
     * FontAwesome or custom icon class
     * 
     * @var string
     */
    private string $icon = 'fas fa-folder';

    /**
     * Manual sorting order
     * 
     * @var int
     */
    private int $sort_order = 0;

    /**
     * Whether category is active and visible
     * 
     * @var bool
     */
    private bool $active = true;

    /**
     * Category constructor
     * 
     * @param string $name Category name
     * @param string $slug URL slug
     */
    public function __construct(string $name, string $slug)
    {
        $this->name = $name;
        $this->slug = $slug;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getName(): string
    {
        return $this->name;
    }

    public function getSlug(): string
    {
        return $this->slug;
    }

    public function getIcon(): string
    {
        return $this->icon;
    }

    public function getSortOrder(): int
    {
        return $this->sort_order;
    }

    public function isActive(): bool
    {
        return $this->active;
    }

    // ==================== SETTER METHODS (Immutable pattern) ====================

    public function setName(string $name): self
    {
        if ($this->name === $name) {
            return $this;
        }
        
        $this->trackChange('name', $this->name, $name);
        $this->name = $name;
        $this->markAsUpdated();
        return $this;
    }

    public function setSlug(string $slug): self
    {
        if ($this->slug === $slug) {
            return $this;
        }
        
        $this->trackChange('slug', $this->slug, $slug);
        $this->slug = $slug;
        $this->markAsUpdated();
        return $this;
    }

    public function setIcon(string $icon): self
    {
        if ($this->icon === $icon) {
            return $this;
        }
        
        $this->trackChange('icon', $this->icon, $icon);
        $this->icon = $icon;
        $this->markAsUpdated();
        return $this;
    }

    public function setSortOrder(int $sort_order): self
    {
        if ($this->sort_order === $sort_order) {
            return $this;
        }
        
        $this->trackChange('sort_order', $this->sort_order, $sort_order);
        $this->sort_order = $sort_order;
        $this->markAsUpdated();
        return $this;
    }

    public function setActive(bool $active): self
    {
        if ($this->active === $active) {
            return $this;
        }
        
        $this->trackChange('active', $this->active, $active);
        $this->active = $active;
        $this->markAsUpdated();
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    public function activate(): self
    {
        return $this->setActive(true);
    }

    public function deactivate(): self
    {
        return $this->setActive(false);
    }

    /**
     * Check if category can be deleted
     * Based on business rule: category should not be deleted if it has products
     * Note: This check should be done at service level with product count
     * 
     * @return bool
     */
    public function canBeDeleted(): bool
    {
        // This is a placeholder - actual check will be in service layer
        // Business rule: categories with products cannot be deleted
        // Return true for now, service layer will enforce business rules
        return true;
    }

    /**
     * Check if category can be archived
     * Business rule: categories with active products cannot be archived
     * 
     * @return bool
     */
    public function canBeArchived(): bool
    {
        // Override parent method to add business logic
        if (!parent::canBeArchived()) {
            return false;
        }
        
        // Additional check: cannot archive if active (must deactivate first)
        if ($this->active) {
            return false;
        }
        
        return $this->canBeDeleted(); // Same rules as deletion
    }

    /**
     * Archive category (soft delete)
     * Override to add custom logic with validation
     * 
     * @return self
     * @throws \LogicException If category cannot be archived
     */
    public function archive(): self
    {
        if (!$this->canBeArchived()) {
            throw new \LogicException('Category cannot be archived. It may have active products or is already archived.');
        }
        
        $this->softDelete();
        $this->deactivate();
        return $this;
    }

    /**
     * Restore category from archive
     * 
     * @return self
     */
    public function restore(): self
    {
        if (!$this->canBeRestored()) {
            throw new \LogicException('Category cannot be restored.');
        }
        
        $this->restoreFromDelete();
        $this->activate();
        return $this;
    }

    /**
     * Check if category is currently in use
     * Business rule: category is in use if it has any published products
     * Note: This check should be done at service level
     * 
     * @return bool
     */
    public function isInUse(): bool
    {
        // This is a placeholder - actual check will be in service layer
        // Business rule: category is in use if it has published products
        return false;
    }

    /**
     * Validate category state
     * Override parent validation with category-specific rules
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $parentValidation = parent::validate();
        $errors = $parentValidation['errors'];
        
        // Category-specific validation
        if (empty($this->name)) {
            $errors[] = 'Category name cannot be empty';
        }
        
        if (empty($this->slug)) {
            $errors[] = 'Category slug cannot be empty';
        }
        
        if (!preg_match('/^[a-z0-9\-]+$/', $this->slug)) {
            $errors[] = 'Category slug can only contain lowercase letters, numbers, and hyphens';
        }
        
        if ($this->sort_order < 0) {
            $errors[] = 'Sort order cannot be negative';
        }
        
        // Business rule: Maximum 15 categories (enforced at service level, not here)
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    /**
     * Get display icon HTML
     * 
     * @return string
     */
    public function getIconHtml(): string
    {
        return sprintf('<i class="%s"></i>', htmlspecialchars($this->icon));
    }

    /**
     * Get Tailwind CSS classes for category display
     * 
     * @return string
     */
    public function getDisplayClasses(): string
    {
        $baseClasses = 'category-item';
        
        if (!$this->active) {
            $baseClasses .= ' opacity-50';
        }
        
        if ($this->isDeleted()) {
            $baseClasses .= ' line-through';
        }
        
        return $baseClasses;
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'name' => $this->getName(),
            'slug' => $this->getSlug(),
            'icon' => $this->getIcon(),
            'icon_html' => $this->getIconHtml(),
            'sort_order' => $this->getSortOrder(),
            'active' => $this->isActive(),
            'is_in_use' => $this->isInUse(),
            'can_be_deleted' => $this->canBeDeleted(),
            'can_be_archived' => $this->canBeArchived(),
            'display_classes' => $this->getDisplayClasses(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
            'is_deleted' => $this->isDeleted(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $category = new self(
            $data['name'] ?? '',
            $data['slug'] ?? ''
        );

        if (isset($data['id'])) {
            $category->setId($data['id']);
        }

        if (isset($data['icon'])) {
            $category->setIcon($data['icon']);
        }

        if (isset($data['sort_order'])) {
            $category->setSortOrder((int) $data['sort_order']);
        }

        if (isset($data['active'])) {
            $category->setActive((bool) $data['active']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $category->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $category->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $category->setDeletedAt($data['deleted_at']);
        }

        return $category;
    }

    /**
     * Create a sample category for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        $category = new self('Electronics', 'electronics');
        $category->setIcon('fas fa-laptop');
        $category->setSortOrder(1);
        return $category;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Marketplace.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Marketplace Entity
 * 
 * Represents an e-commerce marketplace where products are sold.
 * Examples: Tokopedia, Shopee, Lazada, etc.
 * 
 * @package App\Entities
 */
class Marketplace extends BaseEntity
{
    /**
     * Marketplace name
     * 
     * @var string
     */
    private string $name;

    /**
     * URL-friendly slug (unique)
     * 
     * @var string
     */
    private string $slug;

    /**
     * Marketplace icon (FontAwesome or custom)
     * 
     * @var string|null
     */
    private ?string $icon = null;

    /**
     * Brand color in hex format
     * 
     * @var string
     */
    private string $color = '#64748b'; // Default slate-500

    /**
     * Whether marketplace is active in the system
     * 
     * @var bool
     */
    private bool $active = true;

    /**
     * Affiliate commission rate (percentage)
     * 
     * @var string
     */
    private string $commission_rate = '0.00';

    /**
     * Marketplace constructor
     * 
     * @param string $name Marketplace name
     * @param string $slug URL slug
     */
    public function __construct(string $name, string $slug)
    {
        $this->name = $name;
        $this->slug = $slug;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getName(): string
    {
        return $this->name;
    }

    public function getSlug(): string
    {
        return $this->slug;
    }

    public function getIcon(): ?string
    {
        return $this->icon;
    }

    public function getColor(): string
    {
        return $this->color;
    }

    public function isActive(): bool
    {
        return $this->active;
    }

    public function getCommissionRate(): string
    {
        return $this->commission_rate;
    }

    // ==================== SETTER METHODS (Immutable pattern) ====================

    public function setName(string $name): self
    {
        if ($this->name === $name) {
            return $this;
        }
        
        $this->trackChange('name', $this->name, $name);
        $this->name = $name;
        $this->markAsUpdated();
        return $this;
    }

    public function setSlug(string $slug): self
    {
        if ($this->slug === $slug) {
            return $this;
        }
        
        $this->trackChange('slug', $this->slug, $slug);
        $this->slug = $slug;
        $this->markAsUpdated();
        return $this;
    }

    public function setIcon(?string $icon): self
    {
        if ($this->icon === $icon) {
            return $this;
        }
        
        $this->trackChange('icon', $this->icon, $icon);
        $this->icon = $icon;
        $this->markAsUpdated();
        return $this;
    }

    public function setColor(string $color): self
    {
        if (!preg_match('/^#[0-9A-F]{6}$/i', $color)) {
            throw new \InvalidArgumentException('Color must be a valid hex code (e.g., #3b82f6)');
        }
        
        $normalizedColor = strtoupper($color);
        if ($this->color === $normalizedColor) {
            return $this;
        }
        
        $this->trackChange('color', $this->color, $normalizedColor);
        $this->color = $normalizedColor;
        $this->markAsUpdated();
        return $this;
    }

    public function setActive(bool $active): self
    {
        if ($this->active === $active) {
            return $this;
        }
        
        $this->trackChange('active', $this->active, $active);
        $this->active = $active;
        $this->markAsUpdated();
        return $this;
    }

    public function setCommissionRate(string $commission_rate): self
    {
        if (!preg_match('/^\d+\.\d{2}$/', $commission_rate)) {
            throw new \InvalidArgumentException('Commission rate must be in decimal format with 2 decimal places (e.g., 5.00 for 5%)');
        }
        
        if ($this->commission_rate === $commission_rate) {
            return $this;
        }
        
        $this->trackChange('commission_rate', $this->commission_rate, $commission_rate);
        $this->commission_rate = $commission_rate;
        $this->markAsUpdated();
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    public function activate(): self
    {
        return $this->setActive(true);
    }

    public function deactivate(): self
    {
        return $this->setActive(false);
    }

    /**
     * Check if marketplace has an icon
     * 
     * @return bool
     */
    public function hasIcon(): bool
    {
        return $this->icon !== null && $this->icon !== '';
    }

    /**
     * Get CSS classes for marketplace display
     * Useful for frontend styling
     * 
     * @return string
     */
    public function getCssClasses(): string
    {
        $classes = sprintf('marketplace marketplace-%s', $this->slug);
        
        if (!$this->active) {
            $classes .= ' marketplace-inactive';
        }
        
        return $classes;
    }

    /**
     * Get inline style for marketplace color
     * 
     * @return string
     */
    public function getColorStyle(): string
    {
        return sprintf('color: %s;', $this->color);
    }

    /**
     * Get background style for marketplace color
     * 
     * @return string
     */
    public function getBackgroundStyle(): string
    {
        return sprintf('background-color: %s;', $this->color);
    }

    /**
     * Get formatted commission rate for display
     * 
     * @return string
     */
    public function getFormattedCommissionRate(): string
    {
        return number_format((float) $this->commission_rate, 2) . '%';
    }

    /**
     * Calculate commission for a given amount
     * 
     * @param string $amount
     * @return string Commission amount
     */
    public function calculateCommission(string $amount): string
    {
        if (!preg_match('/^\d+\.\d{2}$/', $amount)) {
            throw new \InvalidArgumentException('Amount must be in decimal format with 2 decimal places');
        }
        
        $amountFloat = (float) $amount;
        $rateFloat = (float) $this->commission_rate;
        $commission = ($amountFloat * $rateFloat) / 100;
        
        return number_format($commission, 2, '.', '');
    }

    /**
     * Check if marketplace is currently in use
     * Business rule: marketplace is in use if it has at least 1 active link
     * Note: This check should be done at service level
     * 
     * @return bool
     */
    public function isInUse(): bool
    {
        // This is a placeholder - actual check will be in service layer
        // Business rule: marketplace is in use if it has at least 1 active link
        return false;
    }

    /**
     * Check if marketplace can be archived
     * Business rule: marketplace with active links cannot be archived
     * 
     * @return bool
     */
    public function canBeArchived(): bool
    {
        if (!parent::canBeArchived()) {
            return false;
        }
        
        // Additional check: cannot archive if active (must deactivate first)
        if ($this->active) {
            return false;
        }
        
        return !$this->isInUse();
    }

    /**
     * Archive marketplace (soft delete)
     * Override to add custom logic with validation
     * 
     * @return self
     * @throws \LogicException If marketplace cannot be archived
     */
    public function archive(): self
    {
        if (!$this->canBeArchived()) {
            throw new \LogicException('Marketplace cannot be archived. It may have active links or is already archived.');
        }
        
        $this->softDelete();
        $this->deactivate();
        return $this;
    }

    /**
     * Restore marketplace from archive
     * 
     * @return self
     */
    public function restore(): self
    {
        if (!$this->canBeRestored()) {
            throw new \LogicException('Marketplace cannot be restored.');
        }
        
        $this->restoreFromDelete();
        $this->activate();
        return $this;
    }

    /**
     * Validate marketplace state
     * Override parent validation with marketplace-specific rules
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $parentValidation = parent::validate();
        $errors = $parentValidation['errors'];
        
        // Marketplace-specific validation
        if (empty($this->name)) {
            $errors[] = 'Marketplace name cannot be empty';
        }
        
        if (empty($this->slug)) {
            $errors[] = 'Marketplace slug cannot be empty';
        }
        
        if (!preg_match('/^[a-z0-9\-]+$/', $this->slug)) {
            $errors[] = 'Marketplace slug can only contain lowercase letters, numbers, and hyphens';
        }
        
        if (!preg_match('/^#[0-9A-F]{6}$/i', $this->color)) {
            $errors[] = 'Marketplace color must be a valid hex color code (e.g., #3b82f6)';
        }
        
        $rate = (float) $this->commission_rate;
        if ($rate < 0 || $rate > 100) {
            $errors[] = 'Commission rate must be between 0.00 and 100.00';
        }
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'name' => $this->getName(),
            'slug' => $this->getSlug(),
            'icon' => $this->getIcon(),
            'color' => $this->getColor(),
            'active' => $this->isActive(),
            'commission_rate' => $this->getCommissionRate(),
            'formatted_commission_rate' => $this->getFormattedCommissionRate(),
            'has_icon' => $this->hasIcon(),
            'css_classes' => $this->getCssClasses(),
            'color_style' => $this->getColorStyle(),
            'background_style' => $this->getBackgroundStyle(),
            'is_in_use' => $this->isInUse(),
            'can_be_archived' => $this->canBeArchived(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
            'is_deleted' => $this->isDeleted(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $marketplace = new self(
            $data['name'] ?? '',
            $data['slug'] ?? ''
        );

        if (isset($data['id'])) {
            $marketplace->setId($data['id']);
        }

        if (isset($data['icon'])) {
            $marketplace->setIcon($data['icon']);
        }

        if (isset($data['color'])) {
            $marketplace->setColor($data['color']);
        }

        if (isset($data['active'])) {
            $marketplace->setActive((bool) $data['active']);
        }

        if (isset($data['commission_rate'])) {
            $marketplace->setCommissionRate($data['commission_rate']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $marketplace->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $marketplace->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $marketplace->setDeletedAt($data['deleted_at']);
        }

        return $marketplace;
    }

    /**
     * Create a default marketplace instance
     * Useful for testing or fallback
     * 
     * @return static
     */
    public static function createDefault(): static
    {
        return new self('Unknown Marketplace', 'unknown');
    }

    /**
     * Create sample marketplaces for testing/demo
     * 
     * @return static[]
     */
    public static function createSamples(): array
    {
        return [
            (new self('Tokopedia', 'tokopedia'))
                ->setIcon('fas fa-store')
                ->setColor('#42B549')
                ->setCommissionRate('5.00'),
            
            (new self('Shopee', 'shopee'))
                ->setIcon('fas fa-shopping-cart')
                ->setColor('#FF5316')
                ->setCommissionRate('4.50'),
            
            (new self('Lazada', 'lazada'))
                ->setIcon('fas fa-bolt')
                ->setColor('#0F146C')
                ->setCommissionRate('6.00'),
            
            (new self('Blibli', 'blibli'))
                ->setIcon('fas fa-box')
                ->setColor('#E60012')
                ->setCommissionRate('5.50'),
        ];
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Badge.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Badge Entity
 * 
 * Represents a product badge/tag for visual categorization and highlighting.
 * Examples: "Best Seller", "New Arrival", "Limited Edition", etc.
 * 
 * @package App\Entities
 */
class Badge extends BaseEntity
{
    /**
     * Badge label/name
     * 
     * @var string
     */
    private string $label;

    /**
     * Badge color in hex format
     * 
     * @var string|null
     */
    private ?string $color = null;

    /**
     * Badge constructor
     * 
     * @param string $label Badge display label
     */
    public function __construct(string $label)
    {
        $this->label = $label;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getLabel(): string
    {
        return $this->label;
    }

    public function getColor(): ?string
    {
        return $this->color;
    }

    // ==================== SETTER METHODS (Immutable pattern) ====================

    public function setLabel(string $label): self
    {
        if ($this->label === $label) {
            return $this;
        }
        
        $this->trackChange('label', $this->label, $label);
        $this->label = $label;
        $this->markAsUpdated();
        return $this;
    }

    public function setColor(?string $color): self
    {
        if ($color !== null && !preg_match('/^#[0-9A-F]{6}$/i', $color)) {
            throw new \InvalidArgumentException('Color must be a valid hex code (e.g., #ef4444) or null');
        }
        
        $normalizedColor = $color !== null ? strtoupper($color) : null;
        if ($this->color === $normalizedColor) {
            return $this;
        }
        
        $this->trackChange('color', $this->color, $normalizedColor);
        $this->color = $normalizedColor;
        $this->markAsUpdated();
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    /**
     * Check if badge has a custom color
     * 
     * @return bool
     */
    public function hasColor(): bool
    {
        return $this->color !== null;
    }

    /**
     * Get CSS color style for badge display
     * Returns inline style if color is set, empty string otherwise
     * 
     * @return string
     */
    public function getColorStyle(): string
    {
        if (!$this->hasColor()) {
            return '';
        }
        
        return sprintf('background-color: %s; color: white;', $this->color);
    }

    /**
     * Get Tailwind CSS classes for badge display
     * Based on business need for consistent styling
     * 
     * @return string
     */
    public function getTailwindClasses(): string
    {
        $baseClasses = 'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium';
        
        if ($this->hasColor()) {
            // For custom colors, we'll use inline style
            return $baseClasses;
        }
        
        // Default color scheme based on badge type
        $colorMap = [
            'Best Seller' => 'bg-red-100 text-red-800',
            'New Arrival' => 'bg-green-100 text-green-800',
            'Limited Edition' => 'bg-purple-100 text-purple-800',
            'Exclusive' => 'bg-yellow-100 text-yellow-800',
            'Trending' => 'bg-blue-100 text-blue-800',
            'Verified' => 'bg-emerald-100 text-emerald-800',
            'Discount' => 'bg-pink-100 text-pink-800',
            'Premium' => 'bg-amber-100 text-amber-800',
        ];
        
        return $baseClasses . ' ' . ($colorMap[$this->label] ?? 'bg-gray-100 text-gray-800');
    }

    /**
     * Get FontAwesome icon for badge type
     * 
     * @return string
     */
    public function getIcon(): string
    {
        $iconMap = [
            'Best Seller' => 'fas fa-trophy',
            'New Arrival' => 'fas fa-star',
            'Limited Edition' => 'fas fa-clock',
            'Exclusive' => 'fas fa-crown',
            'Trending' => 'fas fa-chart-line',
            'Verified' => 'fas fa-check-circle',
            'Discount' => 'fas fa-tag',
            'Premium' => 'fas fa-gem',
        ];
        
        return $iconMap[$this->label] ?? 'fas fa-tag';
    }

    /**
     * Check if badge is currently in use by any active product
     * Note: This check should be done at service level
     * 
     * @return bool
     */
    public function isInUse(): bool
    {
        // This is a placeholder - actual check will be in service layer
        // Business rule: badge is in use if assigned to any active product
        return false;
    }

    /**
     * Check if badge can be archived
     * Business rule: badge in use cannot be archived
     * 
     * @return bool
     */
    public function canBeArchived(): bool
    {
        if (!parent::canBeArchived()) {
            return false;
        }
        
        return !$this->isInUse();
    }

    /**
     * Archive badge (soft delete) with usage check
     * 
     * @return self
     * @throws \LogicException If badge cannot be archived
     */
    public function archive(): self
    {
        if (!$this->canBeArchived()) {
            throw new \LogicException('Badge cannot be archived because it is still in use by active products.');
        }
        
        $this->softDelete();
        return $this;
    }

    /**
     * Restore badge from archive
     * 
     * @return self
     */
    public function restore(): self
    {
        if (!$this->canBeRestored()) {
            throw new \LogicException('Badge cannot be restored.');
        }
        
        $this->restoreFromDelete();
        return $this;
    }

    /**
     * Validate badge state
     * Override parent validation with badge-specific rules
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $parentValidation = parent::validate();
        $errors = $parentValidation['errors'];
        
        // Badge-specific validation
        if (empty($this->label)) {
            $errors[] = 'Badge label cannot be empty';
        }
        
        if (strlen($this->label) > 100) {
            $errors[] = 'Badge label cannot exceed 100 characters';
        }
        
        if ($this->color !== null && !preg_match('/^#[0-9A-F]{6}$/i', $this->color)) {
            $errors[] = 'Badge color must be a valid hex color code (e.g., #ef4444) or null';
        }
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'label' => $this->getLabel(),
            'color' => $this->getColor(),
            'has_color' => $this->hasColor(),
            'color_style' => $this->getColorStyle(),
            'tailwind_classes' => $this->getTailwindClasses(),
            'icon' => $this->getIcon(),
            'is_in_use' => $this->isInUse(),
            'can_be_archived' => $this->canBeArchived(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
            'is_deleted' => $this->isDeleted(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $badge = new self($data['label'] ?? '');

        if (isset($data['id'])) {
            $badge->setId($data['id']);
        }

        if (isset($data['color'])) {
            $badge->setColor($data['color']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $badge->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $badge->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $badge->setDeletedAt($data['deleted_at']);
        }

        return $badge;
    }

    /**
     * Create a common badge instance
     * Useful for default badges in the system
     * 
     * @param string $type Type of common badge
     * @return static|null
     */
    public static function createCommon(string $type): ?static
    {
        $commonBadges = [
            'best_seller' => ['label' => 'Best Seller', 'color' => '#EF4444'],
            'new_arrival' => ['label' => 'New Arrival', 'color' => '#10B981'],
            'limited' => ['label' => 'Limited Edition', 'color' => '#8B5CF6'],
            'exclusive' => ['label' => 'Exclusive', 'color' => '#F59E0B'],
            'trending' => ['label' => 'Trending', 'color' => '#3B82F6'],
            'verified' => ['label' => 'Verified', 'color' => '#059669'],
            'discount' => ['label' => 'Discount', 'color' => '#EC4899'],
            'premium' => ['label' => 'Premium', 'color' => '#D97706'],
        ];

        if (!isset($commonBadges[$type])) {
            return null;
        }

        $badge = new self($commonBadges[$type]['label']);
        $badge->setColor($commonBadges[$type]['color']);
        
        return $badge;
    }

    /**
     * Create all common badges for system initialization
     * 
     * @return static[]
     */
    public static function createAllCommon(): array
    {
        $types = [
            'best_seller',
            'new_arrival', 
            'limited',
            'exclusive',
            'trending',
            'verified',
            'discount',
            'premium',
        ];
        
        $badges = [];
        foreach ($types as $type) {
            $badge = self::createCommon($type);
            if ($badge !== null) {
                $badges[] = $badge;
            }
        }
        
        return $badges;
    }

    /**
     * Create a sample badge for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        return self::createCommon('best_seller') ?? new self('Sample Badge');
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/MarketplaceBadge.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * MarketplaceBadge Entity
 * 
 * Represents a badge specific to marketplace stores/sellers.
 * Examples: "Official Store", "Top Seller", "Verified Seller", "Fast Delivery"
 * These badges are displayed next to store names in product links.
 * 
 * @package App\Entities
 */
class MarketplaceBadge extends BaseEntity
{
    /**
     * Badge label/name
     * 
     * @var string
     */
    private string $label;

    /**
     * Badge icon (FontAwesome class or custom icon)
     * 
     * @var string|null
     */
    private ?string $icon = null;

    /**
     * Badge color in hex format
     * 
     * @var string|null
     */
    private ?string $color = null;

    /**
     * Badge constructor
     * 
     * @param string $label Badge display label
     */
    public function __construct(string $label)
    {
        $this->label = $label;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getLabel(): string
    {
        return $this->label;
    }

    public function getIcon(): ?string
    {
        return $this->icon;
    }

    public function getColor(): ?string
    {
        return $this->color;
    }

    // ==================== SETTER METHODS (Immutable pattern) ====================

    public function setLabel(string $label): self
    {
        if ($this->label === $label) {
            return $this;
        }
        
        $this->trackChange('label', $this->label, $label);
        $this->label = $label;
        $this->markAsUpdated();
        return $this;
    }

    public function setIcon(?string $icon): self
    {
        if ($this->icon === $icon) {
            return $this;
        }
        
        $this->trackChange('icon', $this->icon, $icon);
        $this->icon = $icon;
        $this->markAsUpdated();
        return $this;
    }

    public function setColor(?string $color): self
    {
        if ($color !== null && !preg_match('/^#[0-9A-F]{6}$/i', $color)) {
            throw new \InvalidArgumentException('Color must be a valid hex code (e.g., #10B981) or null');
        }
        
        $normalizedColor = $color !== null ? strtoupper($color) : null;
        if ($this->color === $normalizedColor) {
            return $this;
        }
        
        $this->trackChange('color', $this->color, $normalizedColor);
        $this->color = $normalizedColor;
        $this->markAsUpdated();
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    /**
     * Check if badge has an icon
     * 
     * @return bool
     */
    public function hasIcon(): bool
    {
        return $this->icon !== null && $this->icon !== '';
    }

    /**
     * Check if badge has a custom color
     * 
     * @return bool
     */
    public function hasColor(): bool
    {
        return $this->color !== null;
    }

    /**
     * Get CSS color style for badge display
     * Returns inline style if color is set, empty string otherwise
     * 
     * @return string
     */
    public function getColorStyle(): string
    {
        if (!$this->hasColor()) {
            return '';
        }
        
        return sprintf('color: %s;', $this->color);
    }

    /**
     * Get HTML for badge display
     * Combines icon and label for consistent rendering
     * 
     * @return string
     */
    public function getDisplayHtml(): string
    {
        $iconHtml = '';
        $colorStyle = $this->getColorStyle();
        
        if ($this->hasIcon()) {
            $iconHtml = sprintf('<i class="%s mr-1" style="%s"></i>', 
                $this->icon, 
                $colorStyle
            );
        }
        
        return sprintf(
            '<span class="inline-flex items-center text-xs font-medium" style="%s">%s%s</span>',
            $colorStyle,
            $iconHtml,
            htmlspecialchars($this->label)
        );
    }

    /**
     * Get Tailwind CSS classes for badge display
     * Based on badge type for consistent styling
     * 
     * @return string
     */
    public function getTailwindClasses(): string
    {
        $baseClasses = 'inline-flex items-center text-xs font-medium';
        
        if ($this->hasColor()) {
            // For custom colors, we'll use inline style
            return $baseClasses;
        }
        
        // Default color scheme based on badge type
        $colorMap = [
            'Official Store' => 'text-emerald-600',
            'Top Seller' => 'text-amber-600',
            'Verified Seller' => 'text-blue-600',
            'Fast Delivery' => 'text-purple-600',
            'Recommended' => 'text-rose-600',
            'Trusted' => 'text-green-600',
            'Choice' => 'text-indigo-600',
            'Premium Seller' => 'text-yellow-600',
        ];
        
        return $baseClasses . ' ' . ($colorMap[$this->label] ?? 'text-gray-600');
    }

    /**
     * Check if badge is currently assigned to any active link
     * Note: This check should be done at service level
     * 
     * @return bool
     */
    public function isAssigned(): bool
    {
        // This is a placeholder - actual check will be in service layer
        // Business rule: badge is assigned if used by any active link
        return false;
    }

    /**
     * Check if badge can be archived
     * Business rule: badge assigned to active links cannot be archived
     * 
     * @return bool
     */
    public function canBeArchived(): bool
    {
        if (!parent::canBeArchived()) {
            return false;
        }
        
        return !$this->isAssigned();
    }

    /**
     * Archive badge (soft delete) with assignment check
     * 
     * @return self
     * @throws \LogicException If badge cannot be archived
     */
    public function archive(): self
    {
        if (!$this->canBeArchived()) {
            throw new \LogicException('Marketplace badge cannot be archived because it is still assigned to active links.');
        }
        
        $this->softDelete();
        return $this;
    }

    /**
     * Restore badge from archive
     * 
     * @return self
     */
    public function restore(): self
    {
        if (!$this->canBeRestored()) {
            throw new \LogicException('Marketplace badge cannot be restored.');
        }
        
        $this->restoreFromDelete();
        return $this;
    }

    /**
     * Validate badge state
     * Override parent validation with marketplace badge-specific rules
     * 
     * @return array{valid: bool, errors: string[]}
     */
    public function validate(): array
    {
        $parentValidation = parent::validate();
        $errors = $parentValidation['errors'];
        
        // Marketplace badge-specific validation
        if (empty($this->label)) {
            $errors[] = 'Marketplace badge label cannot be empty';
        }
        
        if (strlen($this->label) > 100) {
            $errors[] = 'Marketplace badge label cannot exceed 100 characters';
        }
        
        if ($this->icon !== null && strlen($this->icon) > 100) {
            $errors[] = 'Marketplace badge icon cannot exceed 100 characters';
        }
        
        if ($this->color !== null && !preg_match('/^#[0-9A-F]{6}$/i', $this->color)) {
            $errors[] = 'Marketplace badge color must be a valid hex color code (e.g., #10B981) or null';
        }
        
        return [
            'valid' => empty($errors),
            'errors' => $errors
        ];
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'label' => $this->getLabel(),
            'icon' => $this->getIcon(),
            'color' => $this->getColor(),
            'has_icon' => $this->hasIcon(),
            'has_color' => $this->hasColor(),
            'color_style' => $this->getColorStyle(),
            'display_html' => $this->getDisplayHtml(),
            'tailwind_classes' => $this->getTailwindClasses(),
            'is_assigned' => $this->isAssigned(),
            'can_be_archived' => $this->canBeArchived(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
            'is_deleted' => $this->isDeleted(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $badge = new self($data['label'] ?? '');

        if (isset($data['id'])) {
            $badge->setId($data['id']);
        }

        if (isset($data['icon'])) {
            $badge->setIcon($data['icon']);
        }

        if (isset($data['color'])) {
            $badge->setColor($data['color']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $badge->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $badge->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $badge->setDeletedAt($data['deleted_at']);
        }

        return $badge;
    }

    /**
     * Create a common marketplace badge instance
     * Useful for default marketplace badges in the system
     * 
     * @param string $type Type of common badge
     * @return static|null
     */
    public static function createCommon(string $type): ?static
    {
        $commonBadges = [
            'official_store' => [
                'label' => 'Official Store', 
                'icon' => 'fas fa-check-circle',
                'color' => '#059669'
            ],
            'top_seller' => [
                'label' => 'Top Seller', 
                'icon' => 'fas fa-crown',
                'color' => '#D97706'
            ],
            'verified_seller' => [
                'label' => 'Verified Seller', 
                'icon' => 'fas fa-shield-check',
                'color' => '#2563EB'
            ],
            'fast_delivery' => [
                'label' => 'Fast Delivery', 
                'icon' => 'fas fa-shipping-fast',
                'color' => '#7C3AED'
            ],
            'recommended' => [
                'label' => 'Recommended', 
                'icon' => 'fas fa-thumbs-up',
                'color' => '#DC2626'
            ],
            'trusted' => [
                'label' => 'Trusted', 
                'icon' => 'fas fa-award',
                'color' => '#059669'
            ],
            'choice' => [
                'label' => 'Choice', 
                'icon' => 'fas fa-star',
                'color' => '#4F46E5'
            ],
            'premium_seller' => [
                'label' => 'Premium Seller', 
                'icon' => 'fas fa-gem',
                'color' => '#F59E0B'
            ],
        ];

        if (!isset($commonBadges[$type])) {
            return null;
        }

        $badge = new self($commonBadges[$type]['label']);
        $badge->setIcon($commonBadges[$type]['icon']);
        $badge->setColor($commonBadges[$type]['color']);
        
        return $badge;
    }

    /**
     * Create all common marketplace badges for system initialization
     * 
     * @return static[]
     */
    public static function createAllCommon(): array
    {
        $types = [
            'official_store',
            'top_seller',
            'verified_seller',
            'fast_delivery',
            'recommended',
            'trusted',
            'choice',
            'premium_seller',
        ];
        
        $badges = [];
        foreach ($types as $type) {
            $badge = self::createCommon($type);
            if ($badge !== null) {
                $badges[] = $badge;
            }
        }
        
        return $badges;
    }

    /**
     * Create a sample marketplace badge for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        return self::createCommon('official_store') ?? new self('Sample Marketplace Badge');
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Product.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use App\Enums\ProductStatus;
use App\Enums\ImageSourceType;
use DateTimeImmutable;

/**
 * Product Entity
 * 
 * Represents the core product in the system. Limited to 300 premium products.
 * Each product undergoes manual curation with strict quality control.
 * 
 * @package App\Entities
 */
class Product extends BaseEntity
{
    /**
     * Category ID (foreign key)
     * 
     * @var int|null
     */
    private ?int $category_id = null;

    /**
     * URL-friendly slug (unique)
     * 
     * @var string
     */
    private string $slug;

    /**
     * Main product image URL
     * 
     * @var string|null
     */
    private ?string $image = null;

    /**
     * Product name
     * 
     * @var string
     */
    private string $name;

    /**
     * Product description
     * 
     * @var string|null
     */
    private ?string $description = null;

    /**
     * Market reference price (decimal)
     * 
     * @var string
     */
    private string $market_price = '0.00';

    /**
     * View count for popularity tracking
     * 
     * @var int
     */
    private int $view_count = 0;

    /**
     * Local image path if uploaded
     * 
     * @var string|null
     */
    private ?string $image_path = null;

    /**
     * Image source type
     * 
     * @var ImageSourceType
     */
    private ImageSourceType $image_source_type;

    /**
     * Product workflow status
     * 
     * @var ProductStatus
     */
    private ProductStatus $status;

    /**
     * Publication timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $published_at = null;

    /**
     * Verification timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $verified_at = null;

    /**
     * Admin ID who verified the product
     * 
     * @var int|null
     */
    private ?int $verified_by = null;

    /**
     * Last price check timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $last_price_check = null;

    /**
     * Last link validation timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $last_link_check = null;

    /**
     * Product constructor
     * 
     * @param string $name Product name
     * @param string $slug URL slug
     */
    public function __construct(string $name, string $slug)
    {
        $this->name = $name;
        $this->slug = $slug;
        $this->status = ProductStatus::DRAFT;
        $this->image_source_type = ImageSourceType::URL;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getCategoryId(): ?int
    {
        return $this->category_id;
    }

    public function getSlug(): string
    {
        return $this->slug;
    }

    public function getImage(): ?string
    {
        return $this->image;
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getDescription(): ?string
    {
        return $this->description;
    }

    public function getMarketPrice(): string
    {
        return $this->market_price;
    }

    public function getViewCount(): int
    {
        return $this->view_count;
    }

    public function getImagePath(): ?string
    {
        return $this->image_path;
    }

    public function getImageSourceType(): ImageSourceType
    {
        return $this->image_source_type;
    }

    public function getStatus(): ProductStatus
    {
        return $this->status;
    }

    public function getPublishedAt(): ?DateTimeImmutable
    {
        return $this->published_at;
    }

    public function getVerifiedAt(): ?DateTimeImmutable
    {
        return $this->verified_at;
    }

    public function getVerifiedBy(): ?int
    {
        return $this->verified_by;
    }

    public function getLastPriceCheck(): ?DateTimeImmutable
    {
        return $this->last_price_check;
    }

    public function getLastLinkCheck(): ?DateTimeImmutable
    {
        return $this->last_link_check;
    }

    // ==================== SETTER METHODS ====================

    public function setCategoryId(?int $category_id): self
    {
        if ($this->category_id === $category_id) {
            return $this;
        }
        $this->category_id = $category_id;
        $this->markAsUpdated();
        return $this;
    }

    public function setSlug(string $slug): self
    {
        if ($this->slug === $slug) {
            return $this;
        }
        $this->slug = $slug;
        $this->markAsUpdated();
        return $this;
    }

    public function setImage(?string $image): self
    {
        if ($this->image === $image) {
            return $this;
        }
        $this->image = $image;
        $this->markAsUpdated();
        return $this;
    }

    public function setName(string $name): self
    {
        if ($this->name === $name) {
            return $this;
        }
        $this->name = $name;
        $this->markAsUpdated();
        return $this;
    }

    public function setDescription(?string $description): self
    {
        if ($this->description === $description) {
            return $this;
        }
        $this->description = $description;
        $this->markAsUpdated();
        return $this;
    }

    public function setMarketPrice(string $market_price): self
    {
        if (!preg_match('/^\d+\.\d{2}$/', $market_price)) {
            throw new \InvalidArgumentException('Market price must be in decimal format with 2 decimal places (e.g., 1234.56)');
        }
        
        if ($this->market_price === $market_price) {
            return $this;
        }
        $this->market_price = $market_price;
        $this->markAsUpdated();
        return $this;
    }

    public function setViewCount(int $view_count): self
    {
        if ($this->view_count === $view_count) {
            return $this;
        }
        $this->view_count = $view_count;
        $this->markAsUpdated();
        return $this;
    }

    public function setImagePath(?string $image_path): self
    {
        if ($this->image_path === $image_path) {
            return $this;
        }
        $this->image_path = $image_path;
        $this->markAsUpdated();
        return $this;
    }

    public function setImageSourceType(ImageSourceType $image_source_type): self
    {
        if ($this->image_source_type === $image_source_type) {
            return $this;
        }
        $this->image_source_type = $image_source_type;
        $this->markAsUpdated();
        return $this;
    }

    public function setStatus(ProductStatus $status): self
    {
        if ($this->status === $status) {
            return $this;
        }
        
        if (!$this->status->canTransitionTo($status)) {
            throw new \InvalidArgumentException(
                sprintf('Cannot transition product status from %s to %s', 
                    $this->status->label(), 
                    $status->label()
                )
            );
        }
        
        $this->status = $status;
        $this->markAsUpdated();
        
        // Auto-set timestamps based on status transitions
        if ($status === ProductStatus::PUBLISHED && $this->published_at === null) {
            $this->published_at = new DateTimeImmutable();
        }
        
        return $this;
    }

    public function setPublishedAt(?DateTimeImmutable $published_at): self
    {
        if ($this->published_at === $published_at) {
            return $this;
        }
        $this->published_at = $published_at;
        $this->markAsUpdated();
        return $this;
    }

    public function setVerifiedAt(?DateTimeImmutable $verified_at): self
    {
        if ($this->verified_at === $verified_at) {
            return $this;
        }
        $this->verified_at = $verified_at;
        $this->markAsUpdated();
        return $this;
    }

    public function setVerifiedBy(?int $verified_by): self
    {
        if ($this->verified_by === $verified_by) {
            return $this;
        }
        $this->verified_by = $verified_by;
        $this->markAsUpdated();
        return $this;
    }

    public function setLastPriceCheck(?DateTimeImmutable $last_price_check): self
    {
        if ($this->last_price_check === $last_price_check) {
            return $this;
        }
        $this->last_price_check = $last_price_check;
        // Note: Don't mark as updated for maintenance fields
        return $this;
    }

    public function setLastLinkCheck(?DateTimeImmutable $last_link_check): self
    {
        if ($this->last_link_check === $last_link_check) {
            return $this;
        }
        $this->last_link_check = $last_link_check;
        // Note: Don't mark as updated for maintenance fields
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    public function incrementViewCount(): self
    {
        $this->view_count++;
        // Don't update timestamp for view count increments
        return $this;
    }

    public function requestVerification(): self
    {
        return $this->setStatus(ProductStatus::PENDING_VERIFICATION);
    }

    public function verify(int $adminId): self
    {
        $this->verified_at = new DateTimeImmutable();
        $this->verified_by = $adminId;
        return $this->setStatus(ProductStatus::VERIFIED);
    }

    public function publish(): self
    {
        if ($this->status !== ProductStatus::VERIFIED) {
            throw new \LogicException('Only verified products can be published');
        }
        
        $this->published_at = new DateTimeImmutable();
        return $this->setStatus(ProductStatus::PUBLISHED);
    }

    public function archive(): self
    {
        return $this->setStatus(ProductStatus::ARCHIVED);
    }

    public function restore(): self
    {
        if ($this->status !== ProductStatus::ARCHIVED) {
            throw new \LogicException('Only archived products can be restored');
        }
        
        // Restore to previous logical status or default to DRAFT
        return $this->setStatus(ProductStatus::DRAFT);
    }

    public function isPublished(): bool
    {
        return $this->status === ProductStatus::PUBLISHED;
    }

    public function isDraft(): bool
    {
        return $this->status === ProductStatus::DRAFT;
    }

    public function isPendingVerification(): bool
    {
        return $this->status === ProductStatus::PENDING_VERIFICATION;
    }

    public function isVerified(): bool
    {
        return $this->status === ProductStatus::VERIFIED;
    }

    public function isArchived(): bool
    {
        return $this->status === ProductStatus::ARCHIVED;
    }

    public function markPriceChecked(): self
    {
        $this->last_price_check = new DateTimeImmutable();
        return $this;
    }

    public function markLinksChecked(): self
    {
        $this->last_link_check = new DateTimeImmutable();
        return $this;
    }

    public function needsPriceUpdate(): bool
    {
        if ($this->last_price_check === null) {
            return true;
        }
        
        $now = new DateTimeImmutable();
        $interval = $now->diff($this->last_price_check);
        return $interval->days >= 7; // Business rule: 7 days
    }

    public function needsLinkValidation(): bool
    {
        if ($this->last_link_check === null) {
            return true;
        }
        
        $now = new DateTimeImmutable();
        $interval = $now->diff($this->last_link_check);
        return $interval->days >= 14; // Business rule: 14 days
    }

    public function getDisplayImageUrl(): ?string
    {
        if ($this->image_source_type === ImageSourceType::UPLOAD && $this->image_path !== null) {
            return '/uploads/products/' . $this->image_path;
        }
        
        return $this->image;
    }

    public function getFormattedMarketPrice(): string
    {
        return 'Rp ' . number_format((float) $this->market_price, 0, ',', '.');
    }

    public function getStatusLabel(): string
    {
        return $this->status->label();
    }

    public function getStatusColorClass(): string
    {
        return $this->status->colorClass();
    }

    public function getStatusIcon(): string
    {
        return $this->status->icon();
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'category_id' => $this->getCategoryId(),
            'slug' => $this->getSlug(),
            'image' => $this->getImage(),
            'name' => $this->getName(),
            'description' => $this->getDescription(),
            'market_price' => $this->getMarketPrice(),
            'formatted_market_price' => $this->getFormattedMarketPrice(),
            'view_count' => $this->getViewCount(),
            'image_path' => $this->getImagePath(),
            'image_source_type' => $this->getImageSourceType()->value,
            'status' => $this->getStatus()->value,
            'status_label' => $this->getStatusLabel(),
            'status_color' => $this->getStatusColorClass(),
            'status_icon' => $this->getStatusIcon(),
            'published_at' => $this->getPublishedAt(),
            'verified_at' => $this->getVerifiedAt(),
            'verified_by' => $this->getVerifiedBy(),
            'last_price_check' => $this->getLastPriceCheck(),
            'last_link_check' => $this->getLastLinkCheck(),
            'is_published' => $this->isPublished(),
            'is_draft' => $this->isDraft(),
            'is_pending_verification' => $this->isPendingVerification(),
            'is_verified' => $this->isVerified(),
            'is_archived' => $this->isArchived(),
            'display_image_url' => $this->getDisplayImageUrl(),
            'needs_price_update' => $this->needsPriceUpdate(),
            'needs_link_validation' => $this->needsLinkValidation(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $product = new self(
            $data['name'] ?? '',
            $data['slug'] ?? ''
        );

        if (isset($data['id'])) {
            $product->setId($data['id']);
        }

        if (isset($data['category_id'])) {
            $product->setCategoryId($data['category_id']);
        }

        if (isset($data['image'])) {
            $product->setImage($data['image']);
        }

        if (isset($data['description'])) {
            $product->setDescription($data['description']);
        }

        if (isset($data['market_price'])) {
            $product->setMarketPrice($data['market_price']);
        }

        if (isset($data['view_count'])) {
            $product->setViewCount((int) $data['view_count']);
        }

        if (isset($data['image_path'])) {
            $product->setImagePath($data['image_path']);
        }

        if (isset($data['image_source_type'])) {
            $product->setImageSourceType(ImageSourceType::from($data['image_source_type']));
        }

        if (isset($data['status'])) {
            $product->setStatus(ProductStatus::from($data['status']));
        }

        if (isset($data['published_at']) && $data['published_at'] instanceof DateTimeImmutable) {
            $product->setPublishedAt($data['published_at']);
        }

        if (isset($data['verified_at']) && $data['verified_at'] instanceof DateTimeImmutable) {
            $product->setVerifiedAt($data['verified_at']);
        }

        if (isset($data['verified_by'])) {
            $product->setVerifiedBy($data['verified_by']);
        }

        if (isset($data['last_price_check']) && $data['last_price_check'] instanceof DateTimeImmutable) {
            $product->setLastPriceCheck($data['last_price_check']);
        }

        if (isset($data['last_link_check']) && $data['last_link_check'] instanceof DateTimeImmutable) {
            $product->setLastLinkCheck($data['last_link_check']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $product->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $product->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $product->setDeletedAt($data['deleted_at']);
        }

        return $product;
    }

    public static function createSample(): static
    {
        $product = new self(
            'Sample Premium Product',
            'sample-premium-product'
        );
        
        $product->setDescription('This is a sample product description for testing purposes.');
        $product->setMarketPrice('1250000.00');
        $product->setImage('https://via.placeholder.com/400x300');
        $product->verify(1); // Admin ID 1
        $product->publish();
        
        return $product;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Link.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

use DateTimeImmutable;

/**
 * Link Entity
 * 
 * Represents a product link to a specific marketplace/store.
 * Core of the affiliate monetization system.
 * Each product must have at least 3 marketplace links (business rule).
 * 
 * @package App\Entities
 */
class Link extends BaseEntity
{
    /**
     * Product ID (foreign key)
     * 
     * @var int
     */
    private int $product_id;

    /**
     * Marketplace ID (foreign key)
     * 
     * @var int
     */
    private int $marketplace_id;

    /**
     * Store name on the marketplace
     * 
     * @var string
     */
    private string $store_name;

    /**
     * Current price on the marketplace (decimal)
     * 
     * @var string
     */
    private string $price = '0.00';

    /**
     * Affiliate URL
     * 
     * @var string|null
     */
    private ?string $url = null;

    /**
     * Store rating (0.00 to 5.00)
     * 
     * @var string
     */
    private string $rating = '0.00';

    /**
     * Whether the link is active
     * 
     * @var bool
     */
    private bool $active = true;

    /**
     * Number of items sold (from the store)
     * 
     * @var int
     */
    private int $sold_count = 0;

    /**
     * Number of clicks on this affiliate link
     * For basic analytics
     * 
     * @var int
     */
    private int $clicks = 0;

    /**
     * Last price update timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $last_price_update = null;

    /**
     * Last link validation timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $last_validation = null;

    /**
     * Estimated affiliate revenue from this link
     * 
     * @var string
     */
    private string $affiliate_revenue = '0.00';

    /**
     * Marketplace badge ID (foreign key)
     * e.g., "Official Store", "Top Seller"
     * 
     * @var int|null
     */
    private ?int $marketplace_badge_id = null;

    /**
     * Link constructor
     * 
     * @param int $product_id
     * @param int $marketplace_id
     * @param string $store_name
     */
    public function __construct(int $product_id, int $marketplace_id, string $store_name)
    {
        $this->product_id = $product_id;
        $this->marketplace_id = $marketplace_id;
        $this->store_name = $store_name;
        $this->initialize();
    }

    // ==================== GETTER METHODS ====================

    public function getProductId(): int
    {
        return $this->product_id;
    }

    public function getMarketplaceId(): int
    {
        return $this->marketplace_id;
    }

    public function getStoreName(): string
    {
        return $this->store_name;
    }

    public function getPrice(): string
    {
        return $this->price;
    }

    public function getUrl(): ?string
    {
        return $this->url;
    }

    public function getRating(): string
    {
        return $this->rating;
    }

    public function isActive(): bool
    {
        return $this->active;
    }

    public function getSoldCount(): int
    {
        return $this->sold_count;
    }

    public function getClicks(): int
    {
        return $this->clicks;
    }

    public function getLastPriceUpdate(): ?DateTimeImmutable
    {
        return $this->last_price_update;
    }

    public function getLastValidation(): ?DateTimeImmutable
    {
        return $this->last_validation;
    }

    public function getAffiliateRevenue(): string
    {
        return $this->affiliate_revenue;
    }

    public function getMarketplaceBadgeId(): ?int
    {
        return $this->marketplace_badge_id;
    }

    // ==================== SETTER METHODS ====================

    public function setProductId(int $product_id): self
    {
        if ($this->product_id === $product_id) {
            return $this;
        }
        $this->product_id = $product_id;
        $this->markAsUpdated();
        return $this;
    }

    public function setMarketplaceId(int $marketplace_id): self
    {
        if ($this->marketplace_id === $marketplace_id) {
            return $this;
        }
        $this->marketplace_id = $marketplace_id;
        $this->markAsUpdated();
        return $this;
    }

    public function setStoreName(string $store_name): self
    {
        if ($this->store_name === $store_name) {
            return $this;
        }
        $this->store_name = $store_name;
        $this->markAsUpdated();
        return $this;
    }

    public function setPrice(string $price): self
    {
        if (!preg_match('/^\d+\.\d{2}$/', $price)) {
            throw new \InvalidArgumentException('Price must be in decimal format with 2 decimal places (e.g., 1234.56)');
        }
        
        if ($this->price === $price) {
            return $this;
        }
        
        $oldPrice = $this->price;
        $this->price = $price;
        $this->markAsUpdated();
        
        // Auto-update last_price_update timestamp when price changes
        if ($oldPrice !== $price) {
            $this->last_price_update = new DateTimeImmutable();
        }
        
        return $this;
    }

    public function setUrl(?string $url): self
    {
        if ($this->url === $url) {
            return $this;
        }
        $this->url = $url;
        $this->markAsUpdated();
        return $this;
    }

    public function setRating(string $rating): self
    {
        $ratingFloat = (float) $rating;
        
        if ($ratingFloat < 0.00 || $ratingFloat > 5.00) {
            throw new \InvalidArgumentException('Rating must be between 0.00 and 5.00');
        }
        
        if (!preg_match('/^\d+\.\d{2}$/', $rating)) {
            throw new \InvalidArgumentException('Rating must have exactly 2 decimal places');
        }
        
        if ($this->rating === $rating) {
            return $this;
        }
        $this->rating = $rating;
        $this->markAsUpdated();
        return $this;
    }

    public function setActive(bool $active): self
    {
        if ($this->active === $active) {
            return $this;
        }
        $this->active = $active;
        $this->markAsUpdated();
        return $this;
    }

    public function setSoldCount(int $sold_count): self
    {
        if ($this->sold_count === $sold_count) {
            return $this;
        }
        $this->sold_count = $sold_count;
        $this->markAsUpdated();
        return $this;
    }

    public function setClicks(int $clicks): self
    {
        if ($this->clicks === $clicks) {
            return $this;
        }
        $this->clicks = $clicks;
        // Don't update timestamp for clicks changes (analytics only)
        return $this;
    }

    public function setLastPriceUpdate(?DateTimeImmutable $last_price_update): self
    {
        if ($this->last_price_update === $last_price_update) {
            return $this;
        }
        $this->last_price_update = $last_price_update;
        // Don't update timestamp for maintenance fields
        return $this;
    }

    public function setLastValidation(?DateTimeImmutable $last_validation): self
    {
        if ($this->last_validation === $last_validation) {
            return $this;
        }
        $this->last_validation = $last_validation;
        // Don't update timestamp for maintenance fields
        return $this;
    }

    public function setAffiliateRevenue(string $affiliate_revenue): self
    {
        if (!preg_match('/^\d+\.\d{2}$/', $affiliate_revenue)) {
            throw new \InvalidArgumentException('Affiliate revenue must be in decimal format with 2 decimal places');
        }
        
        if ($this->affiliate_revenue === $affiliate_revenue) {
            return $this;
        }
        $this->affiliate_revenue = $affiliate_revenue;
        // Don't update timestamp for revenue changes
        return $this;
    }

    public function setMarketplaceBadgeId(?int $marketplace_badge_id): self
    {
        if ($this->marketplace_badge_id === $marketplace_badge_id) {
            return $this;
        }
        $this->marketplace_badge_id = $marketplace_badge_id;
        $this->markAsUpdated();
        return $this;
    }

    // ==================== BUSINESS LOGIC METHODS ====================

    public function activate(): self
    {
        return $this->setActive(true);
    }

    public function deactivate(): self
    {
        return $this->setActive(false);
    }

    public function incrementClicks(): self
    {
        $this->clicks++;
        // Log click in service layer, not here
        return $this;
    }

    public function incrementSoldCount(int $increment = 1): self
    {
        $this->sold_count += $increment;
        $this->markAsUpdated();
        return $this;
    }

    public function addAffiliateRevenue(string $amount): self
    {
        if (!preg_match('/^\d+\.\d{2}$/', $amount)) {
            throw new \InvalidArgumentException('Amount must be in decimal format with 2 decimal places');
        }
        
        // String-based addition for decimal precision
        $current = (float) $this->affiliate_revenue;
        $add = (float) $amount;
        $this->affiliate_revenue = number_format($current + $add, 2, '.', '');
        
        return $this;
    }

    public function updatePrice(string $newPrice, bool $autoUpdateTimestamp = true): self
    {
        $oldPrice = $this->price;
        $this->setPrice($newPrice);
        
        // Only update timestamp if explicitly requested
        if ($autoUpdateTimestamp && $oldPrice !== $newPrice) {
            $this->last_price_update = new DateTimeImmutable();
        }
        
        return $this;
    }

    public function markAsValidated(): self
    {
        $this->last_validation = new DateTimeImmutable();
        return $this;
    }

    public function markAsInvalid(): self
    {
        $this->active = false;
        $this->markAsUpdated();
        return $this;
    }

    public function hasMarketplaceBadge(): bool
    {
        return $this->marketplace_badge_id !== null;
    }

    public function needsPriceUpdate(): bool
    {
        if ($this->last_price_update === null) {
            return true;
        }
        
        $now = new DateTimeImmutable();
        $interval = $now->diff($this->last_price_update);
        return $interval->days >= 7; // Business rule: update every 7 days
    }

    public function needsValidation(): bool
    {
        if ($this->last_validation === null) {
            return true;
        }
        
        $now = new DateTimeImmutable();
        $interval = $now->diff($this->last_validation);
        return $interval->days >= 14; // Business rule: validate every 14 days
    }

    public function isValid(): bool
    {
        return $this->active && $this->url !== null && $this->url !== '';
    }

    public function isAffiliateActive(): bool
    {
        return $this->isValid() && $this->clicks > 0;
    }

    public function getFormattedPrice(): string
    {
        return 'Rp ' . number_format((float) $this->price, 0, ',', '.');
    }

    public function getFormattedRating(): string
    {
        return number_format((float) $this->rating, 1);
    }

    public function getFormattedAffiliateRevenue(): string
    {
        return 'Rp ' . number_format((float) $this->affiliate_revenue, 0, ',', '.');
    }

    public function getStarRatingHtml(): string
    {
        $rating = (float) $this->rating;
        $fullStars = floor($rating);
        $halfStar = ($rating - $fullStars) >= 0.5;
        $emptyStars = 5 - $fullStars - ($halfStar ? 1 : 0);
        
        $html = '';
        
        for ($i = 0; $i < $fullStars; $i++) {
            $html .= '<i class="fas fa-star text-yellow-400"></i>';
        }
        
        if ($halfStar) {
            $html .= '<i class="fas fa-star-half-alt text-yellow-400"></i>';
        }
        
        for ($i = 0; $i < $emptyStars; $i++) {
            $html .= '<i class="far fa-star text-yellow-400"></i>';
        }
        
        return $html;
    }

    public function getFormattedSoldCount(): string
    {
        if ($this->sold_count >= 1000000) {
            return number_format($this->sold_count / 1000000, 1) . 'jt+ terjual';
        }
        
        if ($this->sold_count >= 1000) {
            return number_format($this->sold_count / 1000, 1) . 'rb+ terjual';
        }
        
        return number_format($this->sold_count, 0) . ' terjual';
    }

    public function getClickThroughRate(float $totalProductViews = 0): float
    {
        if ($totalProductViews === 0) {
            return 0.0;
        }
        
        return round(($this->clicks / $totalProductViews) * 100, 2);
    }

    public function getRevenuePerClick(): string
    {
        if ($this->clicks === 0) {
            return '0.00';
        }
        
        $revenue = (float) $this->affiliate_revenue;
        return number_format($revenue / $this->clicks, 2, '.', '');
    }

    public function archive(): self
    {
        $this->softDelete();
        $this->active = false;
        return $this;
    }

    // ==================== SERIALIZATION METHODS ====================

    public function toArray(): array
    {
        return [
            'id' => $this->getId(),
            'product_id' => $this->getProductId(),
            'marketplace_id' => $this->getMarketplaceId(),
            'store_name' => $this->getStoreName(),
            'price' => $this->getPrice(),
            'formatted_price' => $this->getFormattedPrice(),
            'url' => $this->getUrl(),
            'rating' => $this->getRating(),
            'formatted_rating' => $this->getFormattedRating(),
            'star_rating_html' => $this->getStarRatingHtml(),
            'active' => $this->isActive(),
            'sold_count' => $this->getSoldCount(),
            'formatted_sold_count' => $this->getFormattedSoldCount(),
            'clicks' => $this->getClicks(),
            'last_price_update' => $this->getLastPriceUpdate(),
            'last_validation' => $this->getLastValidation(),
            'affiliate_revenue' => $this->getAffiliateRevenue(),
            'formatted_affiliate_revenue' => $this->getFormattedAffiliateRevenue(),
            'marketplace_badge_id' => $this->getMarketplaceBadgeId(),
            'has_marketplace_badge' => $this->hasMarketplaceBadge(),
            'needs_price_update' => $this->needsPriceUpdate(),
            'needs_validation' => $this->needsValidation(),
            'is_valid' => $this->isValid(),
            'is_affiliate_active' => $this->isAffiliateActive(),
            'revenue_per_click' => $this->getRevenuePerClick(),
            'created_at' => $this->getCreatedAt(),
            'updated_at' => $this->getUpdatedAt(),
            'deleted_at' => $this->getDeletedAt(),
        ];
    }

    public static function fromArray(array $data): static
    {
        $link = new self(
            $data['product_id'] ?? 0,
            $data['marketplace_id'] ?? 0,
            $data['store_name'] ?? ''
        );

        if (isset($data['id'])) {
            $link->setId($data['id']);
        }

        if (isset($data['price'])) {
            $link->setPrice($data['price']);
        }

        if (isset($data['url'])) {
            $link->setUrl($data['url']);
        }

        if (isset($data['rating'])) {
            $link->setRating($data['rating']);
        }

        if (isset($data['active'])) {
            $link->setActive((bool) $data['active']);
        }

        if (isset($data['sold_count'])) {
            $link->setSoldCount((int) $data['sold_count']);
        }

        if (isset($data['clicks'])) {
            $link->setClicks((int) $data['clicks']);
        }

        if (isset($data['last_price_update']) && $data['last_price_update'] instanceof DateTimeImmutable) {
            $link->setLastPriceUpdate($data['last_price_update']);
        }

        if (isset($data['last_validation']) && $data['last_validation'] instanceof DateTimeImmutable) {
            $link->setLastValidation($data['last_validation']);
        }

        if (isset($data['affiliate_revenue'])) {
            $link->setAffiliateRevenue($data['affiliate_revenue']);
        }

        if (isset($data['marketplace_badge_id'])) {
            $link->setMarketplaceBadgeId($data['marketplace_badge_id']);
        }

        if (isset($data['created_at']) && $data['created_at'] instanceof DateTimeImmutable) {
            $link->setCreatedAt($data['created_at']);
        }

        if (isset($data['updated_at']) && $data['updated_at'] instanceof DateTimeImmutable) {
            $link->setUpdatedAt($data['updated_at']);
        }

        if (isset($data['deleted_at']) && $data['deleted_at'] instanceof DateTimeImmutable) {
            $link->setDeletedAt($data['deleted_at']);
        }

        return $link;
    }

    public static function createSample(int $productId = 1, int $marketplaceId = 1): static
    {
        $link = new self(
            $productId,
            $marketplaceId,
            'Official Store Example'
        );
        
        $link->setPrice('1250000.00');
        $link->setUrl('https://example.com/affiliate-link');
        $link->setRating('4.75');
        $link->setSoldCount(1250);
        $link->setClicks(42);
        $link->setAffiliateRevenue('52500.00');
        $link->setMarketplaceBadgeId(1);
        $link->markAsValidated();
        
        return $link;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/ProductBadge.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities;

/**
 * ProductBadge Entity
 * 
 * Represents a many-to-many relationship between Products and Badges.
 * This is a junction table entity without timestamps or soft delete.
 * 
 * @package App\Entities
 */
class ProductBadge
{
    /**
     * Product ID (foreign key, part of composite primary key)
     * 
     * @var int
     */
    private int $product_id;

    /**
     * Badge ID (foreign key, part of composite primary key)
     * 
     * @var int
     */
    private int $badge_id;

    /**
     * ProductBadge constructor
     * 
     * @param int $product_id
     * @param int $badge_id
     */
    public function __construct(int $product_id, int $badge_id)
    {
        $this->product_id = $product_id;
        $this->badge_id = $badge_id;
    }

    /**
     * Get product ID
     * 
     * @return int
     */
    public function getProductId(): int
    {
        return $this->product_id;
    }

    /**
     * Set product ID
     * 
     * @param int $product_id
     * @return void
     */
    public function setProductId(int $product_id): void
    {
        $this->product_id = $product_id;
    }

    /**
     * Get badge ID
     * 
     * @return int
     */
    public function getBadgeId(): int
    {
        return $this->badge_id;
    }

    /**
     * Set badge ID
     * 
     * @param int $badge_id
     * @return void
     */
    public function setBadgeId(int $badge_id): void
    {
        $this->badge_id = $badge_id;
    }

    /**
     * Check if this association is for a specific product
     * 
     * @param int $product_id
     * @return bool
     */
    public function isForProduct(int $product_id): bool
    {
        return $this->product_id === $product_id;
    }

    /**
     * Check if this association is for a specific badge
     * 
     * @param int $badge_id
     * @return bool
     */
    public function isForBadge(int $badge_id): bool
    {
        return $this->badge_id === $badge_id;
    }

    /**
     * Get the composite key as an array
     * Useful for database operations
     * 
     * @return array
     */
    public function getCompositeKey(): array
    {
        return [
            'product_id' => $this->product_id,
            'badge_id' => $this->badge_id
        ];
    }

    /**
     * Check if another ProductBadge is equal to this one
     * 
     * @param ProductBadge $other
     * @return bool
     */
    public function equals(ProductBadge $other): bool
    {
        return $this->product_id === $other->getProductId() 
            && $this->badge_id === $other->getBadgeId();
    }

    /**
     * Convert entity to array representation
     * 
     * @return array
     */
    public function toArray(): array
    {
        return [
            'product_id' => $this->getProductId(),
            'badge_id' => $this->getBadgeId(),
            'composite_key' => $this->getCompositeKey(),
        ];
    }

    /**
     * Create ProductBadge from array data
     * 
     * @param array $data
     * @return static
     */
    public static function fromArray(array $data): static
    {
        return new self(
            $data['product_id'] ?? 0,
            $data['badge_id'] ?? 0
        );
    }

    /**
     * Create a sample ProductBadge for testing/demo
     * 
     * @return static
     */
    public static function createSample(): static
    {
        return new self(1, 1); // Assuming product ID 1 and badge ID 1
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Traits/SoftDeletableTrait.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities\Traits;

use DateTimeImmutable;

/**
 * SoftDeletable Trait
 * 
 * Provides soft delete functionality for entities.
 * Instead of physical deletion, sets a deletion timestamp.
 * 
 * @package App\Entities\Traits
 */
trait SoftDeletableTrait
{
    /**
     * Deletion timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $deleted_at = null;

    /**
     * Get deletion timestamp
     * 
     * @return DateTimeImmutable|null
     */
    public function getDeletedAt(): ?DateTimeImmutable
    {
        return $this->deleted_at;
    }

    /**
     * Set deletion timestamp
     * 
     * @param DateTimeImmutable|null $deleted_at
     * @return void
     */
    public function setDeletedAt(?DateTimeImmutable $deleted_at): void
    {
        $this->deleted_at = $deleted_at;
    }

    /**
     * Check if entity is soft-deleted
     * 
     * @return bool
     */
    public function isDeleted(): bool
    {
        return $this->deleted_at !== null;
    }

    /**
     * Soft delete the entity
     * Sets deleted_at to current time
     * 
     * @return void
     */
    public function softDelete(): void
    {
        $this->deleted_at = new DateTimeImmutable();
    }

    /**
     * Restore a soft-deleted entity
     * Sets deleted_at to null
     * 
     * @return void
     */
    public function restore(): void
    {
        $this->deleted_at = null;
    }

    /**
     * Check if entity was deleted within specific days
     * Useful for cleanup or permanent deletion workflows
     * 
     * @param int $days
     * @return bool
     */
    public function wasDeletedWithinDays(int $days): bool
    {
        if ($this->deleted_at === null) {
            return false;
        }

        $now = new DateTimeImmutable();
        $interval = $now->diff($this->deleted_at);
        
        return $interval->days <= $days;
    }

    /**
     * Get days since deletion
     * Returns null if not deleted
     * 
     * @return int|null
     */
    public function getDaysSinceDeletion(): ?int
    {
        if ($this->deleted_at === null) {
            return null;
        }

        $now = new DateTimeImmutable();
        $interval = $now->diff($this->deleted_at);
        
        return $interval->days;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ ENTITIES: app/Entities/Traits/TimestampableTrait.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Entities\Traits;

use DateTimeImmutable;

/**
 * Timestampable Trait
 * 
 * Provides created_at and updated_at timestamps for entities.
 * Using DateTimeImmutable for immutable date objects.
 * 
 * @package App\Entities\Traits
 */
trait TimestampableTrait
{
    /**
     * Creation timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $created_at = null;

    /**
     * Last update timestamp
     * 
     * @var DateTimeImmutable|null
     */
    private ?DateTimeImmutable $updated_at = null;

    /**
     * Get creation timestamp
     * 
     * @return DateTimeImmutable|null
     */
    public function getCreatedAt(): ?DateTimeImmutable
    {
        return $this->created_at;
    }

    /**
     * Set creation timestamp
     * 
     * @param DateTimeImmutable|null $created_at
     * @return void
     */
    public function setCreatedAt(?DateTimeImmutable $created_at): void
    {
        $this->created_at = $created_at;
    }

    /**
     * Get last update timestamp
     * 
     * @return DateTimeImmutable|null
     */
    public function getUpdatedAt(): ?DateTimeImmutable
    {
        return $this->updated_at;
    }

    /**
     * Set last update timestamp
     * 
     * @param DateTimeImmutable|null $updated_at
     * @return void
     */
    public function setUpdatedAt(?DateTimeImmutable $updated_at): void
    {
        $this->updated_at = $updated_at;
    }

    /**
     * Update the updated_at timestamp to current time
     * 
     * @return void
     */
    public function touch(): void
    {
        $this->updated_at = new DateTimeImmutable();
    }

    /**
     * Initialize timestamps on creation
     * Should be called in constructor or factory method
     * 
     * @return void
     */
    public function initializeTimestamps(): void
    {
        $now = new DateTimeImmutable();
        $this->created_at = $now;
        $this->updated_at = $now;
    }

    /**
     * Check if entity is older than specified days
     * Useful for cache invalidation and maintenance checks
     * 
     * @param int $days
     * @return bool
     */
    public function isOlderThanDays(int $days): bool
    {
        if ($this->updated_at === null) {
            return false;
        }

        $now = new DateTimeImmutable();
        $interval = $now->diff($this->updated_at);
        
        return $interval->days > $days;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    MODELS                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Total Entities: 10

ğŸ“ MODELS: app/Models/BaseModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use CodeIgniter\Model;
use App\Entities\BaseEntity;

/**
 * Base Model Abstract Class
 * 
 * Foundation for all models in the system with MVP approach.
 * Provides common configuration and simple caching mechanism.
 * 
 * @package App\Models
 */
abstract class BaseModel extends Model
{
    /**
     * Default cache TTL in seconds (60 minutes)
     * 
     * @var int
     */
    protected const DEFAULT_CACHE_TTL = 3600;

    /**
     * Whether to use soft deletes
     * 
     * @var bool
     */
    protected $useSoftDeletes = true;

    /**
     * Whether to use timestamps
     * 
     * @var bool
     */
    protected $useTimestamps = true;

    /**
     * Field for created_at timestamp
     * 
     * @var string
     */
    protected $createdField = 'created_at';

    /**
     * Field for updated_at timestamp
     * 
     * @var string
     */
    protected $updatedField = 'updated_at';

    /**
     * Field for deleted_at timestamp
     * 
     * @var string
     */
    protected $deletedField = 'deleted_at';

    /**
     * Validation rules for insert/update
     * To be defined in child models
     * 
     * @var array
     */
    protected $validationRules = [];

    /**
     * Validation messages
     * 
     * @var array
     */
    protected $validationMessages = [];

    /**
     * Whether to skip validation
     * 
     * @var bool
     */
    protected $skipValidation = false;

    /**
     * Get cache service instance
     * 
     * @return \CodeIgniter\Cache\CacheInterface
     */
    protected function getCache()
    {
        return \Config\Services::cache();
    }

    /**
     * Execute callback with cache support
     * Simple MVP caching - no tagging, no complex invalidation
     * 
     * @param string $cacheKey Unique cache key
     * @param callable $callback Function that returns data
     * @param int|null $ttl Cache TTL in seconds (null = use default)
     * @return mixed
     */
    protected function cached(string $cacheKey, callable $callback, ?int $ttl = null)
    {
        $cache = $this->getCache();
        $ttl = $ttl ?? static::DEFAULT_CACHE_TTL;
        
        // Try to get from cache first
        $data = $cache->get($cacheKey);
        
        if ($data !== null) {
            return $data;
        }
        
        // Execute callback if not in cache
        $data = $callback();
        
        // Save to cache
        $cache->save($cacheKey, $data, $ttl);
        
        return $data;
    }

    /**
     * Clear cache by key
     * 
     * @param string $cacheKey
     * @return bool
     */
    protected function clearCache(string $cacheKey): bool
    {
        return $this->getCache()->delete($cacheKey);
    }

    /**
     * Generate cache key with prefix
     * 
     * @param string $suffix
     * @return string
     */
    protected function cacheKey(string $suffix): string
    {
        return $this->table . '_' . $suffix;
    }

    /**
     * Find active records (not deleted)
     * 
     * @param array|string|null $columns
     * @return array|object|null
     */
    public function findActive($columns = null)
    {
        return $this->where($this->deletedField, null)->findAll($columns);
    }

    /**
     * Find single active record by ID
     * 
     * @param int|string|null $id
     * @return object|BaseEntity|null
     */
    public function findActiveById($id)
    {
        if ($id === null) {
            return null;
        }
        
        return $this->where($this->table . '.' . $this->primaryKey, $id)
                    ->where($this->deletedField, null)
                    ->first();
    }

    /**
     * Soft delete with validation
     * 
     * @param int|string|null $id
     * @param bool $purge
     * @return bool|BaseEntity
     */
    public function delete($id = null, bool $purge = false)
    {
        // For MVP, we only allow soft deletes
        if ($purge) {
            throw new \RuntimeException('Physical deletes are disabled in MVP. Use archive() method.');
        }
        
        return parent::delete($id);
    }

    /**
     * Archive record (alias for soft delete)
     * 
     * @param int|string $id
     * @return bool
     */
    public function archive($id): bool
    {
        $result = $this->delete($id, false);
        return $result !== false;
    }

    /**
     * Restore archived record
     * 
     * @param int|string $id
     * @return bool
     */
    public function restore($id): bool
    {
        $data = [$this->deletedField => null];
        return $this->update($id, $data);
    }

    /**
     * Get paginated results with simple pagination
     * 
     * @param int $perPage
     * @param int|null $page
     * @return array
     */
    public function paginateSimple(int $perPage = 20, ?int $page = null): array
    {
        $page = $page ?? 1;
        $offset = ($page - 1) * $perPage;
        
        $total = $this->countAllResults();
        $results = $this->limit($perPage, $offset)->findAll();
        
        return [
            'data' => $results,
            'pager' => [
                'current_page' => $page,
                'per_page' => $perPage,
                'total' => $total,
                'total_pages' => ceil($total / $perPage),
                'has_more' => ($page * $perPage) < $total,
            ]
        ];
    }

    /**
     * Update only if values are different
     * Prevents unnecessary database writes and timestamp updates
     * 
     * @param int|string|null $id
     * @param array $data
     * @return bool
     */
    public function updateIfChanged($id = null, array $data = []): bool
    {
        if ($id === null) {
            return false;
        }
        
        // Get current record
        $current = $this->find($id);
        if (!$current) {
            return false;
        }
        
        // Filter out unchanged values
        $changedData = [];
        foreach ($data as $key => $value) {
            if (!property_exists($current, $key) || $current->$key != $value) {
                $changedData[$key] = $value;
            }
        }
        
        // If nothing changed, return true (no update needed)
        if (empty($changedData)) {
            return true;
        }
        
        return $this->update($id, $changedData);
    }

    /**
     * Bulk update with simple validation
     * 
     * @param array $ids
     * @param array $data
     * @return int Number of affected rows
     */
    public function bulkUpdate(array $ids, array $data): int
    {
        if (empty($ids) || empty($data)) {
            return 0;
        }
        
        $builder = $this->builder();
        $builder->whereIn($this->primaryKey, $ids);
        
        // Add updated_at timestamp
        if ($this->useTimestamps && !isset($data[$this->updatedField])) {
            $data[$this->updatedField] = date('Y-m-d H:i:s');
        }
        
        return $builder->update($data) ? count($ids) : 0;
    }

    /**
     * Simple search by keyword across multiple fields
     * 
     * @param string $keyword
     * @param array $searchFields
     * @param int $limit
     * @return array
     */
    public function search(string $keyword, array $searchFields, int $limit = 50): array
    {
        if (empty($keyword) || empty($searchFields)) {
            return [];
        }
        
        $builder = $this->builder();
        
        // Add search conditions for each field
        $first = true;
        foreach ($searchFields as $field) {
            if ($first) {
                $builder->like($field, $keyword);
                $first = false;
            } else {
                $builder->orLike($field, $keyword);
            }
        }
        
        // Only non-deleted records
        $builder->where($this->deletedField, null);
        
        return $builder->limit($limit)->get()->getResult($this->returnType);
    }

    /**
     * Get count of active records
     * 
     * @return int
     */
    public function countActive(): int
    {
        return $this->where($this->deletedField, null)->countAllResults();
    }

    /**
     * Validate data against model rules
     * Simple wrapper for CI4 validation
     * 
     * @param array $data
     * @return array [bool $valid, array $errors]
     */
    public function validateData(array $data): array
    {
        if ($this->skipValidation || empty($this->validationRules)) {
            return [true, []];
        }
        
        $validation = \Config\Services::validation();
        $validation->setRules($this->validationRules, $this->validationMessages);
        
        $isValid = $validation->run($data);
        $errors = $isValid ? [] : $validation->getErrors();
        
        return [$isValid, $errors];
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/LinkModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Link;
use CodeIgniter\Database\BaseBuilder;

/**
 * Link Model
 * 
 * Handles affiliate links, click tracking, and revenue management.
 * Core of the affiliate monetization system with MVP approach.
 * 
 * @package App\Models
 */
class LinkModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'links';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = Link::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'product_id',
        'marketplace_id',
        'store_name',
        'price',
        'url',
        'rating',
        'active',
        'sold_count',
        'clicks',
        'last_price_update',
        'last_validation',
        'affiliate_revenue',
        'marketplace_badge_id',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'product_id'        => 'required|integer',
        'marketplace_id'    => 'required|integer',
        'store_name'        => 'required|min_length[2]|max_length[255]',
        'price'             => 'required|decimal',
        'url'               => 'permit_empty|valid_url|max_length[2000]',
        'rating'            => 'permit_empty|decimal|greater_than_equal_to[0]|less_than_equal_to[5]',
        'active'            => 'permit_empty|in_list[0,1]',
        'sold_count'        => 'permit_empty|integer|greater_than_equal_to[0]',
        'marketplace_badge_id' => 'permit_empty|integer',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'price' => 'ASC',
        'rating' => 'DESC'
    ];

    // ==================== CORE BUSINESS METHODS (6 METHODS) ====================

    /**
     * Find links by product ID
     * Optionally filter by active status
     * 
     * @param int $productId
     * @param bool|null $active null = all, true = active only, false = inactive only
     * @param int $limit
     * @return Link[]
     */
    public function findByProduct(int $productId, ?bool $active = true, int $limit = 10): array
    {
        $cacheKey = $this->cacheKey("product_{$productId}_" . ($active === null ? 'all' : ($active ? 'active' : 'inactive')));
        
        return $this->cached($cacheKey, function() use ($productId, $active, $limit) {
            $builder = $this->builder();
            $builder->where('product_id', $productId)
                    ->where('deleted_at', null);
            
            if ($active !== null) {
                $builder->where('active', $active ? 1 : 0);
            }
            
            return $builder->orderBy('price', 'ASC')
                           ->orderBy('rating', 'DESC')
                           ->limit($limit)
                           ->get()
                           ->getResult($this->returnType);
        }, 1800); // 30 minutes cache
    }

    /**
     * Find active links for a product with marketplace details
     * Used for product comparison table
     * 
     * @param int $productId
     * @return Link[]
     */
    public function findActiveByProduct(int $productId): array
    {
        // This method intentionally not cached because it's called from cached findWithLinks
        $builder = $this->builder();
        
        return $builder->select('links.*')
                       ->join('marketplaces', 'marketplaces.id = links.marketplace_id', 'left')
                       ->where('links.product_id', $productId)
                       ->where('links.active', 1)
                       ->where('links.deleted_at', null)
                       ->where('marketplaces.deleted_at', null)
                       ->orderBy('links.price', 'ASC')
                       ->orderBy('links.rating', 'DESC')
                       ->get()
                       ->getResult($this->returnType);
    }

    /**
     * Increment click count for a link
     * Uses direct SQL to avoid updating timestamps
     * Clears relevant caches
     * 
     * @param int $linkId
     * @return bool
     */
    public function incrementClicks(int $linkId): bool
    {
        // Get product_id for cache clearing
        $link = $this->findActiveById($linkId);
        if (!$link) {
            return false;
        }
        
        // Clear caches that include this link
        $this->clearLinkCaches($link->getProductId(), $linkId);
        
        // Direct SQL to avoid updating timestamps
        $sql = "UPDATE {$this->table} SET clicks = clicks + 1 WHERE id = ?";
        $result = $this->db->query($sql, [$linkId]);
        
        // Also update last_validation timestamp (click indicates link is working)
        if ($result) {
            $this->update($linkId, [
                'last_validation' => date('Y-m-d H:i:s')
            ]);
        }
        
        return $result;
    }

    /**
     * Update link price with timestamp tracking
     * Only updates if price actually changed
     * 
     * @param int $linkId
     * @param string $newPrice Must be in format 1234.56
     * @return bool
     */
    public function updatePrice(int $linkId, string $newPrice): bool
    {
        // Validate price format
        if (!preg_match('/^\d+\.\d{2}$/', $newPrice)) {
            log_message('error', "Invalid price format for link {$linkId}: {$newPrice}");
            return false;
        }
        
        $link = $this->findActiveById($linkId);
        if (!$link) {
            return false;
        }
        
        // Check if price actually changed
        if ($link->getPrice() === $newPrice) {
            return true; // No change needed
        }
        
        // Get product_id for cache clearing
        $productId = $link->getProductId();
        
        // Clear caches
        $this->clearLinkCaches($productId, $linkId);
        
        // Update with new price and timestamp
        return $this->update($linkId, [
            'price' => $newPrice,
            'last_price_update' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Find links that need validation
     * Business rule: validate every 14 days
     * 
     * @param string $type 'validation' or 'price' or 'both'
     * @param int $limit
     * @return Link[]
     */
    public function findExpired(string $type = 'validation', int $limit = 50): array
    {
        $builder = $this->builder();
        $builder->where('active', 1)
                ->where('deleted_at', null);
        
        $now = date('Y-m-d H:i:s');
        
        if ($type === 'validation' || $type === 'both') {
            // Validation needed if last_validation is NULL or older than 14 days
            $builder->groupStart()
                    ->where('last_validation IS NULL')
                    ->orWhere("last_validation <= DATE_SUB('{$now}', INTERVAL 14 DAY)")
                    ->groupEnd();
        }
        
        if ($type === 'price' || $type === 'both') {
            // Price update needed if last_price_update is NULL or older than 7 days
            $builder->groupStart()
                    ->where('last_price_update IS NULL')
                    ->orWhere("last_price_update <= DATE_SUB('{$now}', INTERVAL 7 DAY)")
                    ->groupEnd();
        }
        
        return $builder->limit($limit)
                       ->orderBy('last_validation', 'ASC')
                       ->orderBy('last_price_update', 'ASC')
                       ->get()
                       ->getResult($this->returnType);
    }

    /**
     * Get click statistics for analytics
     * Returns aggregated data for dashboard
     * 
     * @param string $period 'day', 'week', 'month', or 'all'
     * @param int|null $productId Filter by product
     * @param int|null $marketplaceId Filter by marketplace
     * @return array
     */
    public function getClickStats(string $period = 'month', ?int $productId = null, ?int $marketplaceId = null): array
    {
        $cacheKey = $this->cacheKey("click_stats_{$period}_{$productId}_{$marketplaceId}");
        
        return $this->cached($cacheKey, function() use ($period, $productId, $marketplaceId) {
            $builder = $this->builder();
            
            // Select aggregated data
            $builder->select([
                'COUNT(*) as total_links',
                'SUM(clicks) as total_clicks',
                'SUM(affiliate_revenue) as total_revenue',
                'AVG(clicks) as avg_clicks_per_link',
                'MAX(clicks) as max_clicks',
                'MIN(clicks) as min_clicks',
            ]);
            
            // Apply filters
            $builder->where('active', 1)
                    ->where('deleted_at', null);
            
            if ($productId) {
                $builder->where('product_id', $productId);
            }
            
            if ($marketplaceId) {
                $builder->where('marketplace_id', $marketplaceId);
            }
            
            // Apply time period filter based on last_validation
            if ($period !== 'all') {
                $dateField = 'last_validation';
                $intervals = [
                    'day' => '-1 day',
                    'week' => '-1 week',
                    'month' => '-1 month',
                ];
                
                if (isset($intervals[$period])) {
                    $builder->where("{$dateField} >= DATE_SUB(NOW(), INTERVAL 1 {$period})");
                }
            }
            
            $result = $builder->get()->getRowArray();
            
            // Format the result
            if (!$result) {
                return [
                    'total_links' => 0,
                    'total_clicks' => 0,
                    'total_revenue' => '0.00',
                    'avg_clicks_per_link' => 0,
                    'max_clicks' => 0,
                    'min_clicks' => 0,
                    'revenue_per_click' => '0.00',
                ];
            }
            
            // Calculate revenue per click
            $totalClicks = (int) $result['total_clicks'];
            $totalRevenue = (float) $result['total_revenue'];
            $revenuePerClick = $totalClicks > 0 ? $totalRevenue / $totalClicks : 0;
            
            return [
                'total_links' => (int) $result['total_links'],
                'total_clicks' => $totalClicks,
                'total_revenue' => number_format($totalRevenue, 2, '.', ''),
                'avg_clicks_per_link' => round((float) $result['avg_clicks_per_link'], 2),
                'max_clicks' => (int) $result['max_clicks'],
                'min_clicks' => (int) $result['min_clicks'],
                'revenue_per_click' => number_format($revenuePerClick, 2, '.', ''),
            ];
        }, 300); // 5 minutes cache for stats
    }

    // ==================== HELPER METHODS ====================

    /**
     * Clear all caches related to a link
     * 
     * @param int $productId
     * @param int $linkId
     * @return void
     */
    private function clearLinkCaches(int $productId, int $linkId): void
    {
        // Clear link-specific caches
        $cacheKeys = [
            "product_{$productId}_all",
            "product_{$productId}_active",
            "product_{$productId}_inactive",
        ];
        
        foreach ($cacheKeys as $key) {
            $this->clearCache($key);
        }
        
        // Also clear product model caches (since product has links)
        $productModel = model(ProductModel::class);
        $productModel->clearCache($productModel->cacheKey("with_links_{$productId}_active"));
        $productModel->clearCache($productModel->cacheKey("with_links_{$productId}_all"));
    }

    /**
     * Add affiliate revenue to a link
     * Used when affiliate commission is confirmed
     * 
     * @param int $linkId
     * @param string $amount Decimal amount to add
     * @return bool
     */
    public function addAffiliateRevenue(int $linkId, string $amount): bool
    {
        // Validate amount format
        if (!preg_match('/^\d+\.\d{2}$/', $amount)) {
            log_message('error', "Invalid revenue amount format for link {$linkId}: {$amount}");
            return false;
        }
        
        $link = $this->findActiveById($linkId);
        if (!$link) {
            return false;
        }
        
        // Get product_id for cache clearing
        $productId = $link->getProductId();
        
        // Clear caches
        $this->clearLinkCaches($productId, $linkId);
        
        // Use direct SQL to avoid float precision issues
        $sql = "UPDATE {$this->table} SET affiliate_revenue = affiliate_revenue + ? WHERE id = ?";
        return $this->db->query($sql, [(float) $amount, $linkId]);
    }

    /**
     * Mark link as validated (updates last_validation timestamp)
     * 
     * @param int $linkId
     * @return bool
     */
    public function markAsValidated(int $linkId): bool
    {
        $link = $this->findActiveById($linkId);
        if (!$link) {
            return false;
        }
        
        $productId = $link->getProductId();
        $this->clearLinkCaches($productId, $linkId);
        
        return $this->update($linkId, [
            'last_validation' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Update link active status
     * 
     * @param int $linkId
     * @param bool $active
     * @return bool
     */
    public function setActiveStatus(int $linkId, bool $active): bool
    {
        $link = $this->findActiveById($linkId);
        if (!$link) {
            return false;
        }
        
        $productId = $link->getProductId();
        $this->clearLinkCaches($productId, $linkId);
        
        return $this->update($linkId, ['active' => $active ? 1 : 0]);
    }

    /**
     * Find links by marketplace
     * 
     * @param int $marketplaceId
     * @param bool $activeOnly
     * @param int $limit
     * @return Link[]
     */
    public function findByMarketplace(int $marketplaceId, bool $activeOnly = true, int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("marketplace_{$marketplaceId}_" . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($marketplaceId, $activeOnly, $limit) {
            $builder = $this->builder();
            $builder->where('marketplace_id', $marketplaceId)
                    ->where('deleted_at', null);
            
            if ($activeOnly) {
                $builder->where('active', 1);
            }
            
            return $builder->orderBy('clicks', 'DESC')
                           ->limit($limit)
                           ->get()
                           ->getResult($this->returnType);
        }, 1800); // 30 minutes cache
    }

    /**
     * Get top performing links by clicks or revenue
     * 
     * @param string $by 'clicks' or 'revenue'
     * @param int $limit
     * @return Link[]
     */
    public function getTopPerformers(string $by = 'clicks', int $limit = 10): array
    {
        $cacheKey = $this->cacheKey("top_{$by}_{$limit}");
        
        return $this->cached($cacheKey, function() use ($by, $limit) {
            $builder = $this->builder();
            $builder->where('active', 1)
                    ->where('deleted_at', null);
            
            $orderBy = $by === 'revenue' ? 'affiliate_revenue' : 'clicks';
            
            return $builder->orderBy($orderBy, 'DESC')
                           ->limit($limit)
                           ->get()
                           ->getResult($this->returnType);
        }, 300); // 5 minutes cache for top performers
    }

    /**
     * Count active links for a product
     * Business rule: minimum 3 marketplace links per product
     * 
     * @param int $productId
     * @return int
     */
    public function countActiveByProduct(int $productId): int
    {
        $cacheKey = $this->cacheKey("count_active_product_{$productId}");
        
        return $this->cached($cacheKey, function() use ($productId) {
            return $this->where('product_id', $productId)
                       ->where('active', 1)
                       ->where('deleted_at', null)
                       ->countAllResults();
        }, 3600); // 60 minutes cache
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/BadgeModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Badge;

/**
 * Badge Model
 * 
 * Handles product badges (Best Seller, New Arrival, etc.).
 * Simple CRUD with usage tracking for MVP.
 * 
 * @package App\Models
 */
class BadgeModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'badges';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = Badge::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'label',
        'color',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'label' => 'required|min_length[2]|max_length[100]',
        'color' => 'permit_empty|regex_match[/^#[0-9A-F]{6}$/i]',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'label' => 'ASC'
    ];

    // ==================== CORE BUSINESS METHODS (4 METHODS) ====================

    /**
     * Find common badges (system defaults)
     * Returns predefined badges that are commonly used
     * Cached for 60 minutes as badges rarely change
     * 
     * @param bool $activeOnly Only return non-deleted badges
     * @return Badge[]
     */
    public function findCommon(bool $activeOnly = true): array
    {
        $cacheKey = $this->cacheKey('common_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($activeOnly) {
            // Common badge labels (matches Entity's createCommon method)
            $commonLabels = [
                'Best Seller',
                'New Arrival',
                'Limited Edition',
                'Exclusive',
                'Trending',
                'Verified',
                'Discount',
                'Premium',
            ];
            
            $builder = $this->builder();
            $builder->whereIn('label', $commonLabels);
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            return $builder->orderBy('label', 'ASC')
                          ->get()
                          ->getResult($this->returnType);
        }, 3600); // 60 minutes cache
    }

    /**
     * Find active badges (not deleted)
     * Simple active badge retrieval for UI selection
     * 
     * @param int $limit Maximum badges to return
     * @return Badge[]
     */
    public function findActive(int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("active_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            return $this->where('deleted_at', null)
                       ->orderBy('label', 'ASC')
                       ->limit($limit)
                       ->findAll();
        }, 3600); // 60 minutes cache
    }

    /**
     * Find badges with product count (usage statistics)
     * Shows how many products have each badge assigned
     * Used for admin dashboard and badge management
     * 
     * @param int $limit
     * @return Badge[] With attached product_count property
     */
    public function withProductCount(int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("with_product_count_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            // Get all non-deleted badges
            $badges = $this->where('deleted_at', null)
                          ->orderBy('label', 'ASC')
                          ->limit($limit)
                          ->findAll();
            
            if (empty($badges)) {
                return [];
            }
            
            // Get product counts for each badge
            $this->attachProductCounts($badges);
            
            return $badges;
        }, 1800); // 30 minutes cache
    }

    /**
     * Find badge by label (case-insensitive search)
     * Useful for finding or creating badges by label
     * 
     * @param string $label
     * @param bool $activeOnly Only return non-deleted badges
     * @return Badge|null
     */
    public function findByLabel(string $label, bool $activeOnly = true): ?Badge
    {
        $cacheKey = $this->cacheKey("label_" . md5(strtolower($label)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($label, $activeOnly) {
            $builder = $this->builder();
            
            // Case-insensitive search
            $builder->where('LOWER(label)', strtolower($label));
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            $result = $builder->get()->getFirstRow($this->returnType);
            
            return $result instanceof Badge ? $result : null;
        }, 3600); // 60 minutes cache
    }

    // ==================== HELPER METHODS ====================

    /**
     * Attach product counts to badges
     * 
     * @param Badge[] $badges
     * @return void
     */
    private function attachProductCounts(array &$badges): void
    {
        if (empty($badges)) {
            return;
        }
        
        $badgeIds = array_map(fn($badge) => $badge->getId(), $badges);
        
        // Get product counts from junction table
        $productBadgeModel = model(ProductBadgeModel::class);
        $builder = $productBadgeModel->builder();
        
        $result = $builder->select('badge_id, COUNT(*) as product_count')
                         ->whereIn('badge_id', $badgeIds)
                         ->groupBy('badge_id')
                         ->get()
                         ->getResultArray();
        
        // Create lookup array
        $counts = [];
        foreach ($result as $row) {
            $counts[$row['badge_id']] = (int) $row['product_count'];
        }
        
        // Attach counts to badges
        foreach ($badges as $badge) {
            $badgeId = $badge->getId();
            $badge->product_count = $counts[$badgeId] ?? 0;
            $badge->is_in_use = ($counts[$badgeId] ?? 0) > 0;
        }
    }

    /**
     * Check if badge can be deleted
     * Business rule: badge assigned to products cannot be deleted
     * 
     * @param int $badgeId
     * @return array [bool $canDelete, string $reason]
     */
    public function canDelete(int $badgeId): array
    {
        $badge = $this->findActiveById($badgeId);
        if (!$badge) {
            return [false, 'Badge not found'];
        }
        
        // Check if badge is assigned to any products
        $productBadgeModel = model(ProductBadgeModel::class);
        $assignmentCount = $productBadgeModel->countByBadge($badgeId);
        
        if ($assignmentCount > 0) {
            return [false, "Badge is assigned to {$assignmentCount} product(s). Remove assignments first."];
        }
        
        return [true, ''];
    }

    /**
     * Get badge statistics for admin dashboard
     * 
     * @return array
     */
    public function getStats(): array
    {
        $cacheKey = $this->cacheKey('stats');
        
        return $this->cached($cacheKey, function() {
            $total = $this->countActive();
            
            // Get badge usage statistics
            $productBadgeModel = model(ProductBadgeModel::class);
            $builder = $productBadgeModel->builder();
            
            $usageStats = $builder->select('badge_id, COUNT(*) as usage_count')
                                 ->groupBy('badge_id')
                                 ->orderBy('usage_count', 'DESC')
                                 ->get()
                                 ->getResultArray();
            
            $totalAssignments = 0;
            $mostUsedBadge = null;
            
            if (!empty($usageStats)) {
                foreach ($usageStats as $stat) {
                    $totalAssignments += $stat['usage_count'];
                }
                
                // Get most used badge details
                $mostUsed = $usageStats[0];
                $badge = $this->find($mostUsed['badge_id']);
                if ($badge) {
                    $mostUsedBadge = [
                        'badge' => $badge,
                        'usage_count' => (int) $mostUsed['usage_count']
                    ];
                }
            }
            
            // Get badges without color (default styling)
            $noColorCount = $this->where('color IS NULL')
                                ->where('deleted_at', null)
                                ->countAllResults();
            
            $withColorCount = $this->where('color IS NOT NULL')
                                  ->where('deleted_at', null)
                                  ->countAllResults();
            
            return [
                'total_badges' => $total,
                'total_assignments' => $totalAssignments,
                'avg_assignments_per_badge' => $total > 0 ? round($totalAssignments / $total, 2) : 0,
                'most_used_badge' => $mostUsedBadge,
                'badges_without_color' => $noColorCount,
                'badges_with_color' => $withColorCount,
                'color_coverage' => $total > 0 ? round(($withColorCount / $total) * 100, 2) : 0,
            ];
        }, 300); // 5 minutes cache for stats
    }

    /**
     * Find or create badge by label
     * Useful for bulk operations where badges might not exist
     * 
     * @param string $label
     * @param string|null $color Optional hex color
     * @return Badge The found or created badge
     */
    public function findOrCreate(string $label, ?string $color = null): Badge
    {
        // Try to find existing badge
        $badge = $this->findByLabel($label, false); // Include deleted for restoration
        
        if ($badge) {
            // If badge was deleted, restore it
            if ($badge->isDeleted()) {
                $this->restore($badge->getId());
                $badge = $this->find($badge->getId());
            }
            
            // Update color if provided and different
            if ($color !== null && $badge->getColor() !== $color) {
                $this->update($badge->getId(), ['color' => $color]);
                $badge = $this->find($badge->getId());
            }
            
            return $badge;
        }
        
        // Create new badge
        $data = [
            'label' => $label,
            'color' => $color,
        ];
        
        $id = $this->insert($data);
        
        if (!$id) {
            throw new \RuntimeException("Failed to create badge: {$label}");
        }
        
        // Clear caches
        $this->clearBadgeCaches();
        
        return $this->find($id);
    }

    /**
     * Create default badges for system initialization
     * 
     * @return array IDs of created badges
     */
    public function createDefaultBadges(): array
    {
        $defaultBadges = [
            ['label' => 'Best Seller', 'color' => '#EF4444'],
            ['label' => 'New Arrival', 'color' => '#10B981'],
            ['label' => 'Limited Edition', 'color' => '#8B5CF6'],
            ['label' => 'Exclusive', 'color' => '#F59E0B'],
            ['label' => 'Trending', 'color' => '#3B82F6'],
            ['label' => 'Verified', 'color' => '#059669'],
            ['label' => 'Discount', 'color' => '#EC4899'],
            ['label' => 'Premium', 'color' => '#D97706'],
        ];
        
        $createdIds = [];
        
        foreach ($defaultBadges as $badgeData) {
            // Check if badge already exists by label (case-insensitive)
            $existing = $this->findByLabel($badgeData['label'], false);
            
            if (!$existing) {
                if ($id = $this->insert($badgeData)) {
                    $createdIds[] = $id;
                }
            }
        }
        
        // Clear caches after creating defaults
        $this->clearBadgeCaches();
        
        return $createdIds;
    }

    /**
     * Clear all badge caches
     * 
     * @return void
     */
    private function clearBadgeCaches(): void
    {
        $keys = [
            'common_active',
            'common_all',
            'active_50',
            'with_product_count_50',
            'stats',
        ];
        
        foreach ($keys as $key) {
            $this->clearCache($this->cacheKey($key));
        }
    }

    /**
     * Find badges by IDs
     * 
     * @param array $badgeIds
     * @param bool $activeOnly Only return non-deleted badges
     * @return Badge[]
     */
    public function findByIds(array $badgeIds, bool $activeOnly = true): array
    {
        if (empty($badgeIds)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey('ids_' . md5(implode(',', $badgeIds)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($badgeIds, $activeOnly) {
            $builder = $this->builder();
            $builder->whereIn('id', $badgeIds);
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            $builder->orderBy('label', 'ASC');
            
            return $builder->get()->getResult($this->returnType);
        }, 3600);
    }

    /**
     * Search badges by keyword
     * 
     * @param string $keyword
     * @param int $limit
     * @return Badge[]
     */
    public function search(string $keyword, int $limit = 20): array
    {
        if (empty($keyword)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey("search_" . md5($keyword) . "_{$limit}");
        
        return $this->cached($cacheKey, function() use ($keyword, $limit) {
            return $this->like('label', $keyword)
                       ->where('deleted_at', null)
                       ->orderBy('label', 'ASC')
                       ->limit($limit)
                       ->findAll();
        }, 1800); // 30 minutes cache
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/ProductModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Product;
use App\Enums\ProductStatus;

/**
 * Product Model
 * 
 * Core business model for product management with MVP approach.
 * Limited to 8 main methods for 300 premium products.
 * 
 * @package App\Models
 */
class ProductModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'products';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = Product::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'category_id',
        'slug',
        'image',
        'name',
        'description',
        'market_price',
        'view_count',
        'image_path',
        'image_source_type',
        'status',
        'published_at',
        'verified_at',
        'verified_by',
        'last_price_check',
        'last_link_check',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'name'     => 'required|min_length[3]|max_length[255]',
        'slug'     => 'required|alpha_dash|max_length[255]|is_unique[products.slug,id,{id}]',
        'category_id' => 'permit_empty|integer',
        'market_price' => 'required|decimal',
        'status'   => 'required|in_list[draft,pending_verification,verified,published,archived]',
    ];

    /**
     * Validation rules for update
     * 
     * @var array
     */
    protected $validationRulesUpdate = [
        'name'     => 'permit_empty|min_length[3]|max_length[255]',
        'slug'     => 'permit_empty|alpha_dash|max_length[255]|is_unique[products.slug,id,{id}]',
        'market_price' => 'permit_empty|decimal',
        'status'   => 'permit_empty|in_list[draft,pending_verification,verified,published,archived]',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'created_at' => 'DESC'
    ];

    // ==================== CORE BUSINESS METHODS (8 METHODS) ====================

    /**
     * Find published products for public display
     * Cached for 60 minutes for performance
     * 
     * @param int $limit
     * @param int $offset
     * @return Product[]
     */
    public function findPublished(int $limit = 20, int $offset = 0): array
    {
        $cacheKey = $this->cacheKey("published_{$limit}_{$offset}");
        
        return $this->cached($cacheKey, function() use ($limit, $offset) {
            return $this->where('status', ProductStatus::PUBLISHED->value)
                       ->where('deleted_at', null)
                       ->orderBy('published_at', 'DESC')
                       ->orderBy('created_at', 'DESC')
                       ->limit($limit, $offset)
                       ->findAll();
        }, 3600); // 60 minutes cache for public content
    }

    /**
     * Find product by ID or slug (flexible lookup)
     * For public display, only returns published products
     * For admin, can return any status
     * 
     * @param int|string $identifier ID or slug
     * @param bool $adminMode If true, returns any status (for admin)
     * @return Product|null
     */
    public function findByIdOrSlug($identifier, bool $adminMode = false): ?Product
    {
        $cacheKey = $this->cacheKey("lookup_{$identifier}_" . ($adminMode ? 'admin' : 'public'));
        
        return $this->cached($cacheKey, function() use ($identifier, $adminMode) {
            $builder = $this->builder();
            
            // Determine if identifier is ID or slug
            if (is_numeric($identifier)) {
                $builder->where('id', (int) $identifier);
            } else {
                $builder->where('slug', $identifier);
            }
            
            // For public mode, only show published and non-deleted
            if (!$adminMode) {
                $builder->where('status', ProductStatus::PUBLISHED->value)
                        ->where('deleted_at', null);
            } else {
                $builder->where('deleted_at', null); // Admin can see non-deleted only
            }
            
            $result = $builder->get()->getFirstRow($this->returnType);
            
            return $result instanceof Product ? $result : null;
        }, $adminMode ? 60 : 3600); // Shorter cache for admin
    }

    /**
     * Find product with its marketplace links (eager loading)
     * Manual join for MVP - no complex ORM
     * 
     * @param int $productId
     * @param bool $activeOnly Only active links
     * @return Product|null
     */
    public function findWithLinks(int $productId, bool $activeOnly = true): ?Product
    {
        $cacheKey = $this->cacheKey("with_links_{$productId}_" . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($productId, $activeOnly) {
            // First get the product
            $product = $this->findActiveById($productId);
            
            if (!$product) {
                return null;
            }
            
            // Manually load links using LinkModel
            $linkModel = model(LinkModel::class);
            $links = $linkModel->findByProduct($productId, $activeOnly);
            
            // Attach links to product entity
            // Note: We'll use a simple property assignment since entities are mutable in setters
            // In a more complex system, we'd use a proper relation system
            $product->links = $links;
            
            return $product;
        }, 1800); // 30 minutes cache
    }

    /**
     * Increment product view count
     * Uses direct update to avoid updating timestamps
     * 
     * @param int $productId
     * @return bool
     */
    public function incrementViewCount(int $productId): bool
    {
        // Clear cache for this product
        $this->clearCache("lookup_{$productId}_public");
        $this->clearCache("lookup_{$productId}_admin");
        $this->clearCache("with_links_{$productId}_active");
        $this->clearCache("with_links_{$productId}_all");
        
        // Direct SQL to avoid updating updated_at
        $sql = "UPDATE {$this->table} SET view_count = view_count + 1 WHERE id = ?";
        return $this->db->query($sql, [$productId]);
    }

    /**
     * Update product status with validation
     * Ensures valid status transitions based on business rules
     * 
     * @param int $productId
     * @param ProductStatus $newStatus
     * @param int|null $verifiedBy Admin ID for verification
     * @return bool
     */
    public function updateStatus(int $productId, ProductStatus $newStatus, ?int $verifiedBy = null): bool
    {
        // Get current product to validate transition
        $product = $this->findActiveById($productId);
        if (!$product) {
            return false;
        }
        
        // Validate status transition
        $currentStatus = ProductStatus::from($product->status);
        if (!$currentStatus->canTransitionTo($newStatus)) {
            log_message('error', "Invalid status transition from {$currentStatus->value} to {$newStatus->value} for product {$productId}");
            return false;
        }
        
        // Prepare update data
        $updateData = ['status' => $newStatus->value];
        
        // Set timestamps based on status
        if ($newStatus === ProductStatus::PUBLISHED && $product->published_at === null) {
            $updateData['published_at'] = date('Y-m-d H:i:s');
        }
        
        if ($newStatus === ProductStatus::VERIFIED) {
            $updateData['verified_at'] = date('Y-m-d H:i:s');
            $updateData['verified_by'] = $verifiedBy;
        }
        
        // Clear relevant caches
        $this->clearProductCaches($productId);
        
        return $this->update($productId, $updateData);
    }

    /**
     * Find products that need maintenance updates
     * Business rules: price update every 7 days, link validation every 14 days
     * 
     * @param string $type 'price' or 'link' or 'both'
     * @param int $limit
     * @return Product[]
     */
    public function findNeedsUpdate(string $type = 'both', int $limit = 50): array
    {
        $builder = $this->builder();
        $builder->where('status', ProductStatus::PUBLISHED->value)
                ->where('deleted_at', null);
        
        $now = date('Y-m-d H:i:s');
        
        if ($type === 'price' || $type === 'both') {
            // Price check needed if last_price_check is NULL or older than 7 days
            $builder->groupStart()
                    ->where('last_price_check IS NULL')
                    ->orWhere("last_price_check <= DATE_SUB('{$now}', INTERVAL 7 DAY)")
                    ->groupEnd();
        }
        
        if ($type === 'link' || $type === 'both') {
            // Link check needed if last_link_check is NULL or older than 14 days
            $builder->groupStart()
                    ->where('last_link_check IS NULL')
                    ->orWhere("last_link_check <= DATE_SUB('{$now}', INTERVAL 14 DAY)")
                    ->groupEnd();
        }
        
        return $builder->limit($limit)
                       ->orderBy('last_price_check', 'ASC')
                       ->orderBy('last_link_check', 'ASC')
                       ->get()
                       ->getResult($this->returnType);
    }

    /**
     * Search products by keyword (public search)
     * Searches in name and description
     * 
     * @param string $keyword
     * @param int $limit
     * @return Product[]
     */
    public function searchByKeyword(string $keyword, int $limit = 20): array
    {
        if (empty($keyword)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey("search_" . md5($keyword) . "_$limit");
        
        return $this->cached($cacheKey, function() use ($keyword, $limit) {
            $builder = $this->builder();
            $builder->where('status', ProductStatus::PUBLISHED->value)
                    ->where('deleted_at', null)
                    ->groupStart()
                    ->like('name', $keyword)
                    ->orLike('description', $keyword)
                    ->groupEnd()
                    ->orderBy('published_at', 'DESC')
                    ->limit($limit);
            
            return $builder->get()->getResult($this->returnType);
        }, 1800); // 30 minutes cache
    }

    /**
     * Get popular products based on view count
     * 
     * @param int $limit
     * @param string $period 'all', 'week', 'month'
     * @return Product[]
     */
    public function getPopular(int $limit = 10, string $period = 'all'): array
    {
        $cacheKey = $this->cacheKey("popular_{$period}_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit, $period) {
            $builder = $this->builder();
            $builder->where('status', ProductStatus::PUBLISHED->value)
                    ->where('deleted_at', null)
                    ->orderBy('view_count', 'DESC')
                    ->orderBy('published_at', 'DESC')
                    ->limit($limit);
            
            // Apply time period filter if needed
            if ($period === 'week') {
                $builder->where('published_at >=', date('Y-m-d H:i:s', strtotime('-1 week')));
            } elseif ($period === 'month') {
                $builder->where('published_at >=', date('Y-m-d H:i:s', strtotime('-1 month')));
            }
            
            return $builder->get()->getResult($this->returnType);
        }, 1800); // 30 minutes cache
    }

    // ==================== HELPER METHODS ====================

    /**
     * Clear all caches for a product
     * 
     * @param int $productId
     * @return void
     */
    private function clearProductCaches(int $productId): void
    {
        $cacheKeys = [
            "lookup_{$productId}_public",
            "lookup_{$productId}_admin",
            "with_links_{$productId}_active",
            "with_links_{$productId}_all",
        ];
        
        foreach ($cacheKeys as $key) {
            $this->clearCache($key);
        }
        
        // Also clear listing caches
        $this->clearCache($this->cacheKey('published_20_0'));
        $this->clearCache($this->cacheKey('popular_all_10'));
    }

    /**
     * Mark product price as checked
     * Updates last_price_check timestamp
     * 
     * @param int $productId
     * @return bool
     */
    public function markPriceChecked(int $productId): bool
    {
        $this->clearProductCaches($productId);
        return $this->update($productId, [
            'last_price_check' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Mark product links as checked
     * Updates last_link_check timestamp
     * 
     * @param int $productId
     * @return bool
     */
    public function markLinksChecked(int $productId): bool
    {
        $this->clearProductCaches($productId);
        return $this->update($productId, [
            'last_link_check' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Find products by category
     * 
     * @param int $categoryId
     * @param int $limit
     * @param int $offset
     * @return Product[]
     */
    public function findByCategory(int $categoryId, int $limit = 20, int $offset = 0): array
    {
        $cacheKey = $this->cacheKey("category_{$categoryId}_{$limit}_{$offset}");
        
        return $this->cached($cacheKey, function() use ($categoryId, $limit, $offset) {
            return $this->where('category_id', $categoryId)
                       ->where('status', ProductStatus::PUBLISHED->value)
                       ->where('deleted_at', null)
                       ->orderBy('published_at', 'DESC')
                       ->limit($limit, $offset)
                       ->findAll();
        }, 3600); // 60 minutes cache
    }

    /**
     * Count published products
     * 
     * @return int
     */
    public function countPublished(): int
    {
        $cacheKey = $this->cacheKey('count_published');
        
        return $this->cached($cacheKey, function() {
            return $this->where('status', ProductStatus::PUBLISHED->value)
                       ->where('deleted_at', null)
                       ->countAllResults();
        }, 3600); // 60 minutes cache
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/CategoryModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Category;

/**
 * Category Model
 * 
 * Handles product categories with business rule: maximum 15 categories.
 * Simple navigation model for MVP with 5 core methods.
 * 
 * @package App\Models
 */
class CategoryModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'categories';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = Category::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'name',
        'slug',
        'icon',
        'sort_order',
        'active',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'name'       => 'required|min_length[2]|max_length[100]',
        'slug'       => 'required|alpha_dash|max_length[100]|is_unique[categories.slug,id,{id}]',
        'icon'       => 'permit_empty|max_length[255]',
        'sort_order' => 'permit_empty|integer',
        'active'     => 'permit_empty|in_list[0,1]',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'sort_order' => 'ASC',
        'name'       => 'ASC'
    ];

    // ==================== CORE BUSINESS METHODS (5 METHODS) ====================

    /**
     * Find active categories for public display
     * Ordered by sort_order then name
     * Cached for 60 minutes as categories rarely change
     * 
     * @param int $limit Maximum categories to return (business rule: max 15)
     * @return Category[]
     */
    public function findActive(int $limit = 15): array
    {
        $cacheKey = $this->cacheKey("active_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            return $this->where('active', 1)
                       ->where('deleted_at', null)
                       ->orderBy('sort_order', 'ASC')
                       ->orderBy('name', 'ASC')
                       ->limit($limit)
                       ->findAll();
        }, 3600); // 60 minutes cache - categories rarely change
    }

    /**
     * Find categories with product count
     * Used for navigation with product counts
     * Only includes published products in count
     * 
     * @param int $limit Maximum categories to return
     * @return array Categories with product_count property
     */
    public function withProductCount(int $limit = 15): array
    {
        $cacheKey = $this->cacheKey("with_product_count_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            // Get active categories
            $categories = $this->findActive($limit);
            
            if (empty($categories)) {
                return [];
            }
            
            // Get product counts for each category
            $productModel = model(ProductModel::class);
            $categoryIds = array_map(fn($cat) => $cat->getId(), $categories);
            
            // Build a single query to get counts for all categories
            $counts = [];
            if (!empty($categoryIds)) {
                $builder = $productModel->builder();
                $result = $builder->select('category_id, COUNT(*) as product_count')
                                  ->whereIn('category_id', $categoryIds)
                                  ->where('status', 'published')
                                  ->where('deleted_at', null)
                                  ->groupBy('category_id')
                                  ->get()
                                  ->getResultArray();
                
                foreach ($result as $row) {
                    $counts[$row['category_id']] = (int) $row['product_count'];
                }
            }
            
            // Attach product counts to categories
            foreach ($categories as $category) {
                $categoryId = $category->getId();
                $category->product_count = $counts[$categoryId] ?? 0;
            }
            
            // Filter out categories with 0 products (optional)
            // return array_filter($categories, fn($cat) => $cat->product_count > 0);
            
            return $categories;
        }, 1800); // 30 minutes cache
    }

    /**
     * Update category sort order
     * Used for manual ordering in admin interface
     * Business rule: sort_order is manually managed
     * 
     * @param array $orderData Array of [category_id => sort_order]
     * @return bool
     */
    public function updateSortOrder(array $orderData): bool
    {
        if (empty($orderData)) {
            return false;
        }
        
        $this->db->transStart();
        
        try {
            foreach ($orderData as $categoryId => $sortOrder) {
                if (!is_numeric($categoryId) || !is_numeric($sortOrder)) {
                    continue;
                }
                
                $this->update($categoryId, [
                    'sort_order' => (int) $sortOrder
                ]);
            }
            
            $this->db->transComplete();
            
            // Clear all category caches since order changed
            $this->clearAllCategoryCaches();
            
            return $this->db->transStatus();
        } catch (\Exception $e) {
            $this->db->transRollback();
            log_message('error', 'Failed to update category sort order: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Find category by slug
     * Used for routing and URL resolution
     * 
     * @param string $slug
     * @param bool $activeOnly Only return active categories
     * @return Category|null
     */
    public function findBySlug(string $slug, bool $activeOnly = true): ?Category
    {
        $cacheKey = $this->cacheKey("slug_{$slug}_" . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($slug, $activeOnly) {
            $builder = $this->builder();
            $builder->where('slug', $slug)
                    ->where('deleted_at', null);
            
            if ($activeOnly) {
                $builder->where('active', 1);
            }
            
            $result = $builder->get()->getFirstRow($this->returnType);
            
            return $result instanceof Category ? $result : null;
        }, 3600); // 60 minutes cache
    }

    /**
     * Get navigation categories
     * Returns active categories that have at least one published product
     * Used for main navigation menu
     * 
     * @param int $limit
     * @return Category[]
     */
    public function getNavigation(int $limit = 10): array
    {
        $cacheKey = $this->cacheKey("navigation_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            // Get categories with product counts
            $categories = $this->withProductCount($limit);
            
            // Filter out categories with 0 products
            return array_filter($categories, function($category) {
                return $category->product_count > 0;
            });
        }, 1800); // 30 minutes cache
    }

    // ==================== HELPER METHODS ====================

    /**
     * Clear all category caches
     * Used when categories are updated
     * 
     * @return void
     */
    private function clearAllCategoryCaches(): void
    {
        $cache = $this->getCache();
        $prefix = $this->cacheKey('');
        
        // Get all cache items with category prefix
        // Note: This is a simple implementation for MVP
        // In production, you might want a more sophisticated cache invalidation
        $keysToDelete = [
            $this->cacheKey('active_15'),
            $this->cacheKey('with_product_count_15'),
            $this->cacheKey('navigation_10'),
        ];
        
        foreach ($keysToDelete as $key) {
            $this->clearCache($key);
        }
        
        // Also clear any slug-based caches (we don't know all slugs, so we can't clear them all)
        // In MVP, we rely on TTL for slug caches
    }

    /**
     * Check if category can be deleted
     * Business rule: category with products cannot be deleted
     * 
     * @param int $categoryId
     * @return array [bool $canDelete, string $reason]
     */
    public function canDelete(int $categoryId): array
    {
        $category = $this->findActiveById($categoryId);
        if (!$category) {
            return [false, 'Category not found'];
        }
        
        // Check if category has any products
        $productModel = model(ProductModel::class);
        $productCount = $productModel->where('category_id', $categoryId)
                                    ->where('deleted_at', null)
                                    ->countAllResults();
        
        if ($productCount > 0) {
            return [false, "Category has {$productCount} product(s). Remove products first."];
        }
        
        return [true, ''];
    }

    /**
     * Get category statistics for admin dashboard
     * 
     * @return array
     */
    public function getStats(): array
    {
        $cacheKey = $this->cacheKey('stats');
        
        return $this->cached($cacheKey, function() {
            $total = $this->countActive();
            $active = $this->where('active', 1)
                          ->where('deleted_at', null)
                          ->countAllResults();
            
            $inactive = $this->where('active', 0)
                            ->where('deleted_at', null)
                            ->countAllResults();
            
            $archived = $this->where('deleted_at IS NOT NULL')
                            ->countAllResults();
            
            // Get category with most products
            $productModel = model(ProductModel::class);
            $builder = $productModel->builder();
            $mostProducts = $builder->select('category_id, COUNT(*) as product_count')
                                   ->where('category_id IS NOT NULL')
                                   ->where('status', 'published')
                                   ->where('deleted_at', null)
                                   ->groupBy('category_id')
                                   ->orderBy('product_count', 'DESC')
                                   ->limit(1)
                                   ->get()
                                   ->getRowArray();
            
            return [
                'total' => $total,
                'active' => $active,
                'inactive' => $inactive,
                'archived' => $archived,
                'most_popular_category' => $mostProducts ? [
                    'category_id' => $mostProducts['category_id'],
                    'product_count' => (int) $mostProducts['product_count']
                ] : null,
                'limit_remaining' => max(0, 15 - $total), // Business rule: max 15 categories
            ];
        }, 300); // 5 minutes cache for stats
    }

    /**
     * Deactivate category (soft deactivation, not deletion)
     * 
     * @param int $categoryId
     * @return bool
     */
    public function deactivate(int $categoryId): bool
    {
        $result = $this->update($categoryId, ['active' => 0]);
        
        if ($result) {
            $this->clearAllCategoryCaches();
        }
        
        return $result;
    }

    /**
     * Activate category
     * 
     * @param int $categoryId
     * @return bool
     */
    public function activate(int $categoryId): bool
    {
        // Check business rule: maximum 15 active categories
        $activeCount = $this->where('active', 1)
                           ->where('deleted_at', null)
                           ->countAllResults();
        
        if ($activeCount >= 15) {
            log_message('error', 'Cannot activate category: maximum 15 active categories reached');
            return false;
        }
        
        $result = $this->update($categoryId, ['active' => 1]);
        
        if ($result) {
            $this->clearAllCategoryCaches();
        }
        
        return $result;
    }

    /**
     * Find categories by IDs
     * 
     * @param array $categoryIds
     * @param bool $activeOnly
     * @return Category[]
     */
    public function findByIds(array $categoryIds, bool $activeOnly = true): array
    {
        if (empty($categoryIds)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey('ids_' . md5(implode(',', $categoryIds)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($categoryIds, $activeOnly) {
            $builder = $this->builder();
            $builder->whereIn('id', $categoryIds)
                    ->where('deleted_at', null);
            
            if ($activeOnly) {
                $builder->where('active', 1);
            }
            
            $builder->orderBy('sort_order', 'ASC')
                    ->orderBy('name', 'ASC');
            
            return $builder->get()->getResult($this->returnType);
        }, 3600);
    }

    /**
     * Create default categories for system initialization
     * Business rule: Maximum 15 categories total
     * 
     * @return array IDs of created categories
     */
    public function createDefaultCategories(): array
    {
        $defaultCategories = [
            ['name' => 'Electronics', 'slug' => 'electronics', 'icon' => 'fas fa-laptop', 'sort_order' => 1],
            ['name' => 'Fashion', 'slug' => 'fashion', 'icon' => 'fas fa-tshirt', 'sort_order' => 2],
            ['name' => 'Home & Living', 'slug' => 'home-living', 'icon' => 'fas fa-home', 'sort_order' => 3],
            ['name' => 'Beauty', 'slug' => 'beauty', 'icon' => 'fas fa-spa', 'sort_order' => 4],
            ['name' => 'Sports', 'slug' => 'sports', 'icon' => 'fas fa-futbol', 'sort_order' => 5],
            ['name' => 'Books', 'slug' => 'books', 'icon' => 'fas fa-book', 'sort_order' => 6],
            ['name' => 'Toys & Games', 'slug' => 'toys-games', 'icon' => 'fas fa-gamepad', 'sort_order' => 7],
        ];
        
        $createdIds = [];
        
        foreach ($defaultCategories as $categoryData) {
            // Check if category already exists by slug
            $existing = $this->where('slug', $categoryData['slug'])
                            ->where('deleted_at', null)
                            ->first();
            
            if (!$existing) {
                $categoryData['active'] = 1;
                if ($id = $this->insert($categoryData)) {
                    $createdIds[] = $id;
                }
            }
        }
        
        // Clear caches after creating defaults
        $this->clearAllCategoryCaches();
        
        return $createdIds;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/MarketplaceModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Marketplace;

/**
 * Marketplace Model
 * 
 * Handles e-commerce marketplaces (Tokopedia, Shopee, etc.).
 * Simple CRUD with commission rate tracking for MVP.
 * 
 * @package App\Models
 */
class MarketplaceModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'marketplaces';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = Marketplace::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'name',
        'slug',
        'icon',
        'color',
        'active',
        'commission_rate',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'name'            => 'required|min_length[2]|max_length[100]',
        'slug'            => 'required|alpha_dash|max_length[100]|is_unique[marketplaces.slug,id,{id}]',
        'icon'            => 'permit_empty|max_length[255]',
        'color'           => 'permit_empty|regex_match[/^#[0-9A-F]{6}$/i]',
        'active'          => 'permit_empty|in_list[0,1]',
        'commission_rate' => 'permit_empty|decimal|greater_than_equal_to[0]|less_than_equal_to[100]',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'name' => 'ASC'
    ];

    // ==================== CORE BUSINESS METHODS (5 METHODS) ====================

    /**
     * Find active marketplaces for public display
     * Cached for 60 minutes as marketplaces rarely change
     * 
     * @param bool $withStats Include link count statistics
     * @return Marketplace[]
     */
    public function findActive(bool $withStats = false): array
    {
        $cacheKey = $this->cacheKey('active_' . ($withStats ? 'with_stats' : 'basic'));
        
        return $this->cached($cacheKey, function() use ($withStats) {
            $marketplaces = $this->where('active', 1)
                                ->where('deleted_at', null)
                                ->orderBy('name', 'ASC')
                                ->findAll();
            
            if ($withStats && !empty($marketplaces)) {
                $this->attachLinkCounts($marketplaces);
            }
            
            return $marketplaces;
        }, 3600); // 60 minutes cache
    }

    /**
     * Get marketplaces with link count statistics
     * Used for admin dashboard and analytics
     * 
     * @param int $limit
     * @return Marketplace[] With attached link_count property
     */
    public function withLinkCount(int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("with_link_count_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            // Get all active marketplaces
            $marketplaces = $this->where('deleted_at', null)
                                ->orderBy('name', 'ASC')
                                ->limit($limit)
                                ->findAll();
            
            if (empty($marketplaces)) {
                return [];
            }
            
            // Attach link counts
            $this->attachLinkCounts($marketplaces);
            
            return $marketplaces;
        }, 1800); // 30 minutes cache
    }

    /**
     * Get commission statistics per marketplace
     * Returns aggregated revenue and performance data
     * 
     * @param string $period 'day', 'week', 'month', or 'all'
     * @return array
     */
    public function getCommissionStats(string $period = 'month'): array
    {
        $cacheKey = $this->cacheKey("commission_stats_{$period}");
        
        return $this->cached($cacheKey, function() use ($period) {
            // Get all active marketplaces
            $marketplaces = $this->where('active', 1)
                                ->where('deleted_at', null)
                                ->orderBy('name', 'ASC')
                                ->findAll();
            
            if (empty($marketplaces)) {
                return [];
            }
            
            $linkModel = model(LinkModel::class);
            $stats = [];
            
            foreach ($marketplaces as $marketplace) {
                $marketplaceId = $marketplace->getId();
                
                // Get link stats for this marketplace
                $linkStats = $linkModel->getClickStats($period, null, $marketplaceId);
                
                // Calculate estimated commission
                $totalRevenue = (float) $linkStats['total_revenue'];
                $commissionRate = (float) $marketplace->getCommissionRate();
                $estimatedCommission = ($totalRevenue * $commissionRate) / 100;
                
                $stats[] = [
                    'marketplace' => $marketplace,
                    'link_stats' => $linkStats,
                    'estimated_commission' => number_format($estimatedCommission, 2, '.', ''),
                    'commission_rate' => $marketplace->getCommissionRate(),
                    'total_links' => $linkStats['total_links'],
                    'total_clicks' => $linkStats['total_clicks'],
                ];
            }
            
            // Sort by estimated commission (descending)
            usort($stats, function($a, $b) {
                return (float) $b['estimated_commission'] <=> (float) $a['estimated_commission'];
            });
            
            return $stats;
        }, 300); // 5 minutes cache for stats
    }

    /**
     * Find marketplace by slug
     * Used for routing and URL resolution
     * 
     * @param string $slug
     * @param bool $activeOnly Only return active marketplaces
     * @return Marketplace|null
     */
    public function findBySlug(string $slug, bool $activeOnly = true): ?Marketplace
    {
        $cacheKey = $this->cacheKey("slug_{$slug}_" . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($slug, $activeOnly) {
            $builder = $this->builder();
            $builder->where('slug', $slug)
                    ->where('deleted_at', null);
            
            if ($activeOnly) {
                $builder->where('active', 1);
            }
            
            $result = $builder->get()->getFirstRow($this->returnType);
            
            return $result instanceof Marketplace ? $result : null;
        }, 3600); // 60 minutes cache
    }

    /**
     * Update commission rate for a marketplace
     * Validates rate is between 0 and 100
     * 
     * @param int $marketplaceId
     * @param string $newRate Decimal string (e.g., "5.00" for 5%)
     * @return bool
     */
    public function updateCommissionRate(int $marketplaceId, string $newRate): bool
    {
        // Validate rate format and range
        if (!preg_match('/^\d+\.\d{2}$/', $newRate)) {
            log_message('error', "Invalid commission rate format for marketplace {$marketplaceId}: {$newRate}");
            return false;
        }
        
        $rate = (float) $newRate;
        if ($rate < 0 || $rate > 100) {
            log_message('error', "Commission rate out of range for marketplace {$marketplaceId}: {$newRate}");
            return false;
        }
        
        // Clear relevant caches
        $this->clearMarketplaceCaches($marketplaceId);
        
        return $this->update($marketplaceId, [
            'commission_rate' => $newRate
        ]);
    }

    // ==================== HELPER METHODS ====================

    /**
     * Attach link counts to marketplaces
     * 
     * @param Marketplace[] $marketplaces
     * @return void
     */
    private function attachLinkCounts(array &$marketplaces): void
    {
        if (empty($marketplaces)) {
            return;
        }
        
        $marketplaceIds = array_map(fn($mp) => $mp->getId(), $marketplaces);
        
        // Get link counts in a single query
        $linkModel = model(LinkModel::class);
        $builder = $linkModel->builder();
        
        $result = $builder->select('marketplace_id, COUNT(*) as link_count, SUM(clicks) as total_clicks')
                         ->whereIn('marketplace_id', $marketplaceIds)
                         ->where('active', 1)
                         ->where('deleted_at', null)
                         ->groupBy('marketplace_id')
                         ->get()
                         ->getResultArray();
        
        // Create lookup array
        $counts = [];
        foreach ($result as $row) {
            $counts[$row['marketplace_id']] = [
                'link_count' => (int) $row['link_count'],
                'total_clicks' => (int) $row['total_clicks']
            ];
        }
        
        // Attach counts to marketplaces
        foreach ($marketplaces as $marketplace) {
            $marketplaceId = $marketplace->getId();
            $marketplace->link_count = $counts[$marketplaceId]['link_count'] ?? 0;
            $marketplace->total_clicks = $counts[$marketplaceId]['total_clicks'] ?? 0;
            $marketplace->is_in_use = ($counts[$marketplaceId]['link_count'] ?? 0) > 0;
        }
    }

    /**
     * Clear all caches related to a marketplace
     * 
     * @param int $marketplaceId
     * @return void
     */
    private function clearMarketplaceCaches(int $marketplaceId): void
    {
        $cacheKeys = [
            'active_basic',
            'active_with_stats',
            'with_link_count_50',
            "slug_{$marketplaceId}_active",
            "slug_{$marketplaceId}_all",
        ];
        
        // Also clear commission stats caches
        $periods = ['day', 'week', 'month', 'all'];
        foreach ($periods as $period) {
            $cacheKeys[] = "commission_stats_{$period}";
        }
        
        foreach ($cacheKeys as $key) {
            $this->clearCache($this->cacheKey($key));
        }
    }

    /**
     * Check if marketplace can be deleted
     * Business rule: marketplace with active links cannot be deleted
     * 
     * @param int $marketplaceId
     * @return array [bool $canDelete, string $reason]
     */
    public function canDelete(int $marketplaceId): array
    {
        $marketplace = $this->findActiveById($marketplaceId);
        if (!$marketplace) {
            return [false, 'Marketplace not found'];
        }
        
        // Check if marketplace has any active links
        $linkModel = model(LinkModel::class);
        $linkCount = $linkModel->where('marketplace_id', $marketplaceId)
                              ->where('active', 1)
                              ->where('deleted_at', null)
                              ->countAllResults();
        
        if ($linkCount > 0) {
            return [false, "Marketplace has {$linkCount} active link(s). Remove links first."];
        }
        
        return [true, ''];
    }

    /**
     * Get marketplace statistics for admin dashboard
     * 
     * @return array
     */
    public function getStats(): array
    {
        $cacheKey = $this->cacheKey('stats');
        
        return $this->cached($cacheKey, function() {
            $total = $this->countActive();
            $active = $this->where('active', 1)
                          ->where('deleted_at', null)
                          ->countAllResults();
            
            $inactive = $this->where('active', 0)
                            ->where('deleted_at', null)
                            ->countAllResults();
            
            $archived = $this->where('deleted_at IS NOT NULL')
                            ->countAllResults();
            
            // Get marketplace with most links
            $linkModel = model(LinkModel::class);
            $builder = $linkModel->builder();
            $mostLinks = $builder->select('marketplace_id, COUNT(*) as link_count')
                                ->where('marketplace_id IS NOT NULL')
                                ->where('active', 1)
                                ->where('deleted_at', null)
                                ->groupBy('marketplace_id')
                                ->orderBy('link_count', 'DESC')
                                ->limit(1)
                                ->get()
                                ->getRowArray();
            
            // Get total estimated commission
            $totalCommission = 0;
            $marketplaces = $this->where('active', 1)
                                ->where('deleted_at', null)
                                ->findAll();
            
            foreach ($marketplaces as $marketplace) {
                $rate = (float) $marketplace->getCommissionRate();
                // In a real implementation, you would calculate actual commission
                // For MVP, we'll return placeholder
                $totalCommission += $rate;
            }
            
            return [
                'total' => $total,
                'active' => $active,
                'inactive' => $inactive,
                'archived' => $archived,
                'most_used_marketplace' => $mostLinks ? [
                    'marketplace_id' => $mostLinks['marketplace_id'],
                    'link_count' => (int) $mostLinks['link_count']
                ] : null,
                'average_commission_rate' => $active > 0 ? number_format($totalCommission / $active, 2) : '0.00',
            ];
        }, 300); // 5 minutes cache for stats
    }

    /**
     * Find marketplaces by IDs
     * 
     * @param array $marketplaceIds
     * @param bool $activeOnly
     * @return Marketplace[]
     */
    public function findByIds(array $marketplaceIds, bool $activeOnly = true): array
    {
        if (empty($marketplaceIds)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey('ids_' . md5(implode(',', $marketplaceIds)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($marketplaceIds, $activeOnly) {
            $builder = $this->builder();
            $builder->whereIn('id', $marketplaceIds)
                    ->where('deleted_at', null);
            
            if ($activeOnly) {
                $builder->where('active', 1);
            }
            
            $builder->orderBy('name', 'ASC');
            
            return $builder->get()->getResult($this->returnType);
        }, 3600);
    }

    /**
     * Create default marketplaces for system initialization
     * 
     * @return array IDs of created marketplaces
     */
    public function createDefaultMarketplaces(): array
    {
        $defaultMarketplaces = [
            [
                'name' => 'Tokopedia',
                'slug' => 'tokopedia',
                'icon' => 'fas fa-store',
                'color' => '#42B549',
                'commission_rate' => '5.00',
                'active' => 1,
            ],
            [
                'name' => 'Shopee',
                'slug' => 'shopee',
                'icon' => 'fas fa-shopping-cart',
                'color' => '#FF5316',
                'commission_rate' => '4.50',
                'active' => 1,
            ],
            [
                'name' => 'Lazada',
                'slug' => 'lazada',
                'icon' => 'fas fa-bolt',
                'color' => '#0F146C',
                'commission_rate' => '6.00',
                'active' => 1,
            ],
            [
                'name' => 'Blibli',
                'slug' => 'blibli',
                'icon' => 'fas fa-box',
                'color' => '#E60012',
                'commission_rate' => '5.50',
                'active' => 1,
            ],
            [
                'name' => 'Bukalapak',
                'slug' => 'bukalapak',
                'icon' => 'fas fa-shopping-bag',
                'color' => '#E31B23',
                'commission_rate' => '5.25',
                'active' => 1,
            ],
        ];
        
        $createdIds = [];
        
        foreach ($defaultMarketplaces as $marketplaceData) {
            // Check if marketplace already exists by slug
            $existing = $this->where('slug', $marketplaceData['slug'])
                            ->where('deleted_at', null)
                            ->first();
            
            if (!$existing) {
                if ($id = $this->insert($marketplaceData)) {
                    $createdIds[] = $id;
                }
            }
        }
        
        // Clear caches after creating defaults
        $this->clearCache($this->cacheKey('active_basic'));
        $this->clearCache($this->cacheKey('active_with_stats'));
        
        return $createdIds;
    }

    /**
     * Deactivate marketplace
     * 
     * @param int $marketplaceId
     * @return bool
     */
    public function deactivate(int $marketplaceId): bool
    {
        $result = $this->update($marketplaceId, ['active' => 0]);
        
        if ($result) {
            $this->clearMarketplaceCaches($marketplaceId);
        }
        
        return $result;
    }

    /**
     * Activate marketplace
     * 
     * @param int $marketplaceId
     * @return bool
     */
    public function activate(int $marketplaceId): bool
    {
        $result = $this->update($marketplaceId, ['active' => 1]);
        
        if ($result) {
            $this->clearMarketplaceCaches($marketplaceId);
        }
        
        return $result;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/MarketplaceBadgeModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\MarketplaceBadge;

/**
 * MarketplaceBadge Model
 * 
 * Handles marketplace badges (Official Store, Top Seller, etc.).
 * Simple CRUD with assignment tracking for MVP.
 * 
 * @package App\Models
 */
class MarketplaceBadgeModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'marketplace_badges';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Entity class for result objects
     * 
     * @var string
     */
    protected $returnType = MarketplaceBadge::class;

    /**
     * Allowed fields for mass assignment
     * 
     * @var array
     */
    protected $allowedFields = [
        'label',
        'icon',
        'color',
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'label' => 'required|min_length[2]|max_length[100]',
        'icon'  => 'permit_empty|max_length[100]',
        'color' => 'permit_empty|regex_match[/^#[0-9A-F]{6}$/i]',
    ];

    /**
     * Default ordering for queries
     * 
     * @var array
     */
    protected $orderBy = [
        'label' => 'ASC'
    ];

    // ==================== CORE BUSINESS METHODS (4 METHODS) ====================

    /**
     * Find common marketplace badges (system defaults)
     * Returns predefined badges that are commonly used
     * Cached for 60 minutes as badges rarely change
     * 
     * @param bool $activeOnly Only return non-deleted badges
     * @return MarketplaceBadge[]
     */
    public function findCommon(bool $activeOnly = true): array
    {
        $cacheKey = $this->cacheKey('common_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($activeOnly) {
            // Common marketplace badge labels (matches Entity's createCommon method)
            $commonLabels = [
                'Official Store',
                'Top Seller',
                'Verified Seller',
                'Fast Delivery',
                'Recommended',
                'Trusted',
                'Choice',
                'Premium Seller',
            ];
            
            $builder = $this->builder();
            $builder->whereIn('label', $commonLabels);
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            return $builder->orderBy('label', 'ASC')
                          ->get()
                          ->getResult($this->returnType);
        }, 3600); // 60 minutes cache
    }

    /**
     * Find active marketplace badges (not deleted)
     * Simple active badge retrieval for UI selection in links
     * 
     * @param int $limit Maximum badges to return
     * @return MarketplaceBadge[]
     */
    public function findActive(int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("active_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            return $this->where('deleted_at', null)
                       ->orderBy('label', 'ASC')
                       ->limit($limit)
                       ->findAll();
        }, 3600); // 60 minutes cache
    }

    /**
     * Find marketplace badges with link count (usage statistics)
     * Shows how many links have each badge assigned
     * Used for admin dashboard and badge management
     * 
     * @param int $limit
     * @return MarketplaceBadge[] With attached link_count property
     */
    public function withLinkCount(int $limit = 50): array
    {
        $cacheKey = $this->cacheKey("with_link_count_{$limit}");
        
        return $this->cached($cacheKey, function() use ($limit) {
            // Get all non-deleted badges
            $badges = $this->where('deleted_at', null)
                          ->orderBy('label', 'ASC')
                          ->limit($limit)
                          ->findAll();
            
            if (empty($badges)) {
                return [];
            }
            
            // Get link counts for each badge
            $this->attachLinkCounts($badges);
            
            return $badges;
        }, 1800); // 30 minutes cache
    }

    /**
     * Find marketplace badge by label (case-insensitive search)
     * Useful for finding or creating badges by label
     * 
     * @param string $label
     * @param bool $activeOnly Only return non-deleted badges
     * @return MarketplaceBadge|null
     */
    public function findByLabel(string $label, bool $activeOnly = true): ?MarketplaceBadge
    {
        $cacheKey = $this->cacheKey("label_" . md5(strtolower($label)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($label, $activeOnly) {
            $builder = $this->builder();
            
            // Case-insensitive search
            $builder->where('LOWER(label)', strtolower($label));
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            $result = $builder->get()->getFirstRow($this->returnType);
            
            return $result instanceof MarketplaceBadge ? $result : null;
        }, 3600); // 60 minutes cache
    }

    // ==================== HELPER METHODS ====================

    /**
     * Attach link counts to marketplace badges
     * 
     * @param MarketplaceBadge[] $badges
     * @return void
     */
    private function attachLinkCounts(array &$badges): void
    {
        if (empty($badges)) {
            return;
        }
        
        $badgeIds = array_map(fn($badge) => $badge->getId(), $badges);
        
        // Get link counts from links table
        $linkModel = model(LinkModel::class);
        $builder = $linkModel->builder();
        
        $result = $builder->select('marketplace_badge_id, COUNT(*) as link_count')
                         ->whereIn('marketplace_badge_id', $badgeIds)
                         ->where('active', 1)
                         ->where('deleted_at', null)
                         ->groupBy('marketplace_badge_id')
                         ->get()
                         ->getResultArray();
        
        // Create lookup array
        $counts = [];
        foreach ($result as $row) {
            $counts[$row['marketplace_badge_id']] = (int) $row['link_count'];
        }
        
        // Attach counts to badges
        foreach ($badges as $badge) {
            $badgeId = $badge->getId();
            $badge->link_count = $counts[$badgeId] ?? 0;
            $badge->is_assigned = ($counts[$badgeId] ?? 0) > 0;
        }
    }

    /**
     * Check if marketplace badge can be deleted
     * Business rule: badge assigned to active links cannot be deleted
     * 
     * @param int $badgeId
     * @return array [bool $canDelete, string $reason]
     */
    public function canDelete(int $badgeId): array
    {
        $badge = $this->findActiveById($badgeId);
        if (!$badge) {
            return [false, 'Marketplace badge not found'];
        }
        
        // Check if badge is assigned to any active links
        $linkModel = model(LinkModel::class);
        $assignmentCount = $linkModel->where('marketplace_badge_id', $badgeId)
                                    ->where('active', 1)
                                    ->where('deleted_at', null)
                                    ->countAllResults();
        
        if ($assignmentCount > 0) {
            return [false, "Badge is assigned to {$assignmentCount} active link(s). Remove assignments first."];
        }
        
        return [true, ''];
    }

    /**
     * Get marketplace badge statistics for admin dashboard
     * 
     * @return array
     */
    public function getStats(): array
    {
        $cacheKey = $this->cacheKey('stats');
        
        return $this->cached($cacheKey, function() {
            $total = $this->countActive();
            
            // Get badge usage statistics
            $linkModel = model(LinkModel::class);
            $builder = $linkModel->builder();
            
            $usageStats = $builder->select('marketplace_badge_id, COUNT(*) as usage_count')
                                 ->where('marketplace_badge_id IS NOT NULL')
                                 ->where('active', 1)
                                 ->where('deleted_at', null)
                                 ->groupBy('marketplace_badge_id')
                                 ->orderBy('usage_count', 'DESC')
                                 ->get()
                                 ->getResultArray();
            
            $totalAssignments = 0;
            $mostUsedBadge = null;
            
            if (!empty($usageStats)) {
                foreach ($usageStats as $stat) {
                    $totalAssignments += $stat['usage_count'];
                }
                
                // Get most used badge details
                $mostUsed = $usageStats[0];
                $badge = $this->find($mostUsed['marketplace_badge_id']);
                if ($badge) {
                    $mostUsedBadge = [
                        'badge' => $badge,
                        'usage_count' => (int) $mostUsed['usage_count']
                    ];
                }
            }
            
            // Get badges without icon
            $noIconCount = $this->where('icon IS NULL')
                               ->where('deleted_at', null)
                               ->countAllResults();
            
            $withIconCount = $this->where('icon IS NOT NULL')
                                 ->where('deleted_at', null)
                                 ->countAllResults();
            
            // Get badges without color (using default styling)
            $noColorCount = $this->where('color IS NULL')
                                ->where('deleted_at', null)
                                ->countAllResults();
            
            $withColorCount = $this->where('color IS NOT NULL')
                                  ->where('deleted_at', null)
                                  ->countAllResults();
            
            return [
                'total_badges' => $total,
                'total_assignments' => $totalAssignments,
                'avg_assignments_per_badge' => $total > 0 ? round($totalAssignments / $total, 2) : 0,
                'most_used_badge' => $mostUsedBadge,
                'badges_without_icon' => $noIconCount,
                'badges_with_icon' => $withIconCount,
                'badges_without_color' => $noColorCount,
                'badges_with_color' => $withColorCount,
                'icon_coverage' => $total > 0 ? round(($withIconCount / $total) * 100, 2) : 0,
                'color_coverage' => $total > 0 ? round(($withColorCount / $total) * 100, 2) : 0,
            ];
        }, 300); // 5 minutes cache for stats
    }

    /**
     * Find or create marketplace badge by label
     * Useful for bulk operations where badges might not exist
     * 
     * @param string $label
     * @param string|null $icon Optional FontAwesome icon
     * @param string|null $color Optional hex color
     * @return MarketplaceBadge The found or created badge
     */
    public function findOrCreate(string $label, ?string $icon = null, ?string $color = null): MarketplaceBadge
    {
        // Try to find existing badge
        $badge = $this->findByLabel($label, false); // Include deleted for restoration
        
        if ($badge) {
            // If badge was deleted, restore it
            if ($badge->isDeleted()) {
                $this->restore($badge->getId());
                $badge = $this->find($badge->getId());
            }
            
            // Update icon/color if provided and different
            $updateData = [];
            if ($icon !== null && $badge->getIcon() !== $icon) {
                $updateData['icon'] = $icon;
            }
            if ($color !== null && $badge->getColor() !== $color) {
                $updateData['color'] = $color;
            }
            
            if (!empty($updateData)) {
                $this->update($badge->getId(), $updateData);
                $badge = $this->find($badge->getId());
            }
            
            return $badge;
        }
        
        // Create new badge
        $data = [
            'label' => $label,
            'icon'  => $icon,
            'color' => $color,
        ];
        
        $id = $this->insert($data);
        
        if (!$id) {
            throw new \RuntimeException("Failed to create marketplace badge: {$label}");
        }
        
        // Clear caches
        $this->clearMarketplaceBadgeCaches();
        
        return $this->find($id);
    }

    /**
     * Create default marketplace badges for system initialization
     * 
     * @return array IDs of created badges
     */
    public function createDefaultBadges(): array
    {
        $defaultBadges = [
            [
                'label' => 'Official Store',
                'icon' => 'fas fa-check-circle',
                'color' => '#059669'
            ],
            [
                'label' => 'Top Seller',
                'icon' => 'fas fa-crown',
                'color' => '#D97706'
            ],
            [
                'label' => 'Verified Seller',
                'icon' => 'fas fa-shield-check',
                'color' => '#2563EB'
            ],
            [
                'label' => 'Fast Delivery',
                'icon' => 'fas fa-shipping-fast',
                'color' => '#7C3AED'
            ],
            [
                'label' => 'Recommended',
                'icon' => 'fas fa-thumbs-up',
                'color' => '#DC2626'
            ],
            [
                'label' => 'Trusted',
                'icon' => 'fas fa-award',
                'color' => '#059669'
            ],
            [
                'label' => 'Choice',
                'icon' => 'fas fa-star',
                'color' => '#4F46E5'
            ],
            [
                'label' => 'Premium Seller',
                'icon' => 'fas fa-gem',
                'color' => '#F59E0B'
            ],
        ];
        
        $createdIds = [];
        
        foreach ($defaultBadges as $badgeData) {
            // Check if badge already exists by label (case-insensitive)
            $existing = $this->findByLabel($badgeData['label'], false);
            
            if (!$existing) {
                if ($id = $this->insert($badgeData)) {
                    $createdIds[] = $id;
                }
            }
        }
        
        // Clear caches after creating defaults
        $this->clearMarketplaceBadgeCaches();
        
        return $createdIds;
    }

    /**
     * Clear all marketplace badge caches
     * 
     * @return void
     */
    private function clearMarketplaceBadgeCaches(): void
    {
        $keys = [
            'common_active',
            'common_all',
            'active_50',
            'with_link_count_50',
            'stats',
        ];
        
        foreach ($keys as $key) {
            $this->clearCache($this->cacheKey($key));
        }
    }

    /**
     * Find marketplace badges by IDs
     * 
     * @param array $badgeIds
     * @param bool $activeOnly Only return non-deleted badges
     * @return MarketplaceBadge[]
     */
    public function findByIds(array $badgeIds, bool $activeOnly = true): array
    {
        if (empty($badgeIds)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey('ids_' . md5(implode(',', $badgeIds)) . '_' . ($activeOnly ? 'active' : 'all'));
        
        return $this->cached($cacheKey, function() use ($badgeIds, $activeOnly) {
            $builder = $this->builder();
            $builder->whereIn('id', $badgeIds);
            
            if ($activeOnly) {
                $builder->where('deleted_at', null);
            }
            
            $builder->orderBy('label', 'ASC');
            
            return $builder->get()->getResult($this->returnType);
        }, 3600);
    }

    /**
     * Search marketplace badges by keyword
     * 
     * @param string $keyword
     * @param int $limit
     * @return MarketplaceBadge[]
     */
    public function search(string $keyword, int $limit = 20): array
    {
        if (empty($keyword)) {
            return [];
        }
        
        $cacheKey = $this->cacheKey("search_" . md5($keyword) . "_{$limit}");
        
        return $this->cached($cacheKey, function() use ($keyword, $limit) {
            return $this->like('label', $keyword)
                       ->where('deleted_at', null)
                       ->orderBy('label', 'ASC')
                       ->limit($limit)
                       ->findAll();
        }, 1800); // 30 minutes cache
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/ProductBadgeModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\ProductBadge;
use App\Entities\Badge;
use CodeIgniter\Database\Exceptions\DataException;

/**
 * ProductBadge Model
 * 
 * Special handling for composite primary key table (product_id, badge_id)
 * Note: CodeIgniter 4 Models don't natively support composite primary keys
 * 
 * @package App\Models
 */
class ProductBadgeModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'product_badges';

    /**
     * Primary key - using product_id as primary for CI4 Model compatibility
     * Actual composite key: (product_id, badge_id)
     * 
     * @var string
     */
    protected $primaryKey = 'product_id';

    /**
     * Return type
     * 
     * @var string
     */
    protected $returnType = ProductBadge::class;

    /**
     * Allowed fields
     * 
     * @var array
     */
    protected $allowedFields = [
        'product_id',
        'badge_id',
        'assigned_at',
        'assigned_by'
    ];

    /**
     * Use timestamps? NO - table uses assigned_at instead
     * 
     * @var bool
     */
    protected $useTimestamps = false;

    /**
     * Use soft deletes? NO - table doesn't have deleted_at
     * 
     * @var bool
     */
    protected $useSoftDeletes = false;

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'product_id' => 'required|integer|is_not_unique[products.id]',
        'badge_id'   => 'required|integer|is_not_unique[badges.id]',
        'assigned_by' => 'permit_empty|integer|is_not_unique[admins.id]',
        'assigned_at' => 'permit_empty|valid_date'
    ];

    /**
     * Validation messages
     * 
     * @var array
     */
    protected $validationMessages = [
        'product_id' => [
            'required' => 'Product ID is required',
            'is_not_unique' => 'Product does not exist'
        ],
        'badge_id' => [
            'required' => 'Badge ID is required',
            'is_not_unique' => 'Badge does not exist'
        ],
        'assigned_by' => [
            'is_not_unique' => 'Admin does not exist'
        ]
    ];

    /**
     * Before insert callback
     * Set assigned_at if not provided
     * 
     * @param array $data
     * @return array
     */
    protected function beforeInsert(array $data): array
    {
        // Set assigned_at to current time if not provided
        if (!isset($data['assigned_at']) || empty($data['assigned_at'])) {
            $data['assigned_at'] = date('Y-m-d H:i:s');
        }

        return $data;
    }

    /**
     * Find by composite key (product_id + badge_id)
     * This is the actual primary key lookup
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return ProductBadge|null
     */
    public function findByCompositeKey(int $product_id, int $badge_id): ?ProductBadge
    {
        return $this->where('product_id', $product_id)
                    ->where('badge_id', $badge_id)
                    ->first();
    }

    /**
     * Delete by composite key
     * Override parent delete for composite key support
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return bool
     * @throws \Exception
     */
    public function deleteByCompositeKey(int $product_id, int $badge_id): bool
    {
        $builder = $this->builder();
        
        $builder->where('product_id', $product_id);
        $builder->where('badge_id', $badge_id);
        
        $result = $builder->delete();
        
        // Clear relevant caches
        $this->clearBadgeCache($product_id);
        
        return $result !== false;
    }

    /**
     * Assign badge to product
     * Creates relationship if not exists
     * 
     * @param int $product_id
     * @param int $badge_id
     * @param int|null $assigned_by
     * @return bool
     */
    public function assignBadge(int $product_id, int $badge_id, ?int $assigned_by = null): bool
    {
        // Check if relationship already exists
        $existing = $this->findByCompositeKey($product_id, $badge_id);
        if ($existing) {
            // Already assigned
            return true;
        }

        $data = [
            'product_id'  => $product_id,
            'badge_id'    => $badge_id,
            'assigned_by' => $assigned_by
        ];

        $result = $this->insert($data, false); // Don't return ID
        
        if ($result) {
            $this->clearBadgeCache($product_id);
        }
        
        return $result !== false;
    }

    /**
     * Remove badge from product
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return bool
     */
    public function removeBadge(int $product_id, int $badge_id): bool
    {
        return $this->deleteByCompositeKey($product_id, $badge_id);
    }

    /**
     * Get all badges for a product
     * 
     * @param int $product_id
     * @return array
     */
    public function getProductBadges(int $product_id): array
    {
        $cacheKey = $this->cacheKey("product_{$product_id}_badges");
        
        return $this->cached($cacheKey, function() use ($product_id) {
            $badgeModel = model(BadgeModel::class);
            
            $badgeIds = $this->select('badge_id')
                            ->where('product_id', $product_id)
                            ->findAll();
            
            if (empty($badgeIds)) {
                return [];
            }
            
            $ids = array_column($badgeIds, 'badge_id');
            return $badgeModel->findIn('id', $ids);
        });
    }

    /**
     * Get all products for a badge
     * 
     * @param int $badge_id
     * @return array
     */
    public function getBadgeProducts(int $badge_id): array
    {
        $cacheKey = $this->cacheKey("badge_{$badge_id}_products");
        
        return $this->cached($cacheKey, function() use ($badge_id) {
            $productModel = model(ProductModel::class);
            
            $productIds = $this->select('product_id')
                              ->where('badge_id', $badge_id)
                              ->findAll();
            
            if (empty($productIds)) {
                return [];
            }
            
            $ids = array_column($productIds, 'product_id');
            return $productModel->findIn('id', $ids);
        });
    }

    /**
     * Update badge assignments for a product (replace all)
     * 
     * @param int $product_id
     * @param array $badge_ids
     * @param int|null $assigned_by
     * @return bool
     */
    public function updateProductBadges(int $product_id, array $badge_ids, ?int $assigned_by = null): bool
    {
        $this->db->transStart();
        
        try {
            // Remove existing badges
            $this->where('product_id', $product_id)->delete();
            
            // Add new badges
            foreach ($badge_ids as $badge_id) {
                $this->assignBadge($product_id, $badge_id, $assigned_by);
            }
            
            $this->db->transComplete();
            
            if ($this->db->transStatus() === false) {
                return false;
            }
            
            $this->clearBadgeCache($product_id);
            return true;
            
        } catch (\Exception $e) {
            $this->db->transRollback();
            log_message('error', 'Failed to update product badges: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Check if badge is assigned to product
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return bool
     */
    public function isAssigned(int $product_id, int $badge_id): bool
    {
        $count = $this->where('product_id', $product_id)
                      ->where('badge_id', $badge_id)
                      ->countAllResults();
        
        return $count > 0;
    }

    /**
     * Count badges for a product
     * 
     * @param int $product_id
     * @return int
     */
    public function countProductBadges(int $product_id): int
    {
        return $this->where('product_id', $product_id)->countAllResults();
    }

    /**
     * Get assigned_at timestamp for a badge assignment
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return string|null
     */
    public function getAssignmentDate(int $product_id, int $badge_id): ?string
    {
        $assignment = $this->select('assigned_at')
                          ->where('product_id', $product_id)
                          ->where('badge_id', $badge_id)
                          ->first();
        
        return $assignment ? $assignment->assigned_at : null;
    }

    /**
     * Get admin who assigned a badge
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return int|null
     */
    public function getAssignedBy(int $product_id, int $badge_id): ?int
    {
        $assignment = $this->select('assigned_by')
                          ->where('product_id', $product_id)
                          ->where('badge_id', $badge_id)
                          ->first();
        
        return $assignment ? $assignment->assigned_by : null;
    }

    /**
     * Clear badge cache for a product
     * 
     * @param int $product_id
     * @return void
     */
    private function clearBadgeCache(int $product_id): void
    {
        $this->clearCache($this->cacheKey("product_{$product_id}_badges"));
        
        // Also clear any product list caches that might include this product
        $this->clearCache($this->cacheKey('all_active'));
    }

    /**
     * Find badges with assigned products (for admin dashboard)
     * 
     * @return array
     */
    public function getBadgeUsageStats(): array
    {
        $cacheKey = $this->cacheKey('badge_usage_stats');
        
        return $this->cached($cacheKey, function() {
            $sql = "SELECT 
                    b.id as badge_id,
                    b.label as badge_label,
                    COUNT(pb.product_id) as product_count,
                    GROUP_CONCAT(DISTINCT pb.assigned_by) as assigned_admins
                FROM badges b
                LEFT JOIN product_badges pb ON b.id = pb.badge_id
                WHERE b.deleted_at IS NULL
                GROUP BY b.id
                ORDER BY product_count DESC";
            
            $query = $this->db->query($sql);
            return $query->getResultArray();
        }, 1800); // 30 minutes cache
    }

    /**
     * Bulk assign badges to multiple products
     * 
     * @param array $product_ids
     * @param array $badge_ids
     * @param int|null $assigned_by
     * @return array [success_count, failed_count]
     */
    public function bulkAssign(array $product_ids, array $badge_ids, ?int $assigned_by = null): array
    {
        $success = 0;
        $failed = 0;
        
        foreach ($product_ids as $product_id) {
            foreach ($badge_ids as $badge_id) {
                try {
                    if ($this->assignBadge($product_id, $badge_id, $assigned_by)) {
                        $success++;
                    } else {
                        $failed++;
                    }
                } catch (\Exception $e) {
                    $failed++;
                    log_message('error', "Failed to assign badge {$badge_id} to product {$product_id}: " . $e->getMessage());
                }
            }
        }
        
        return [$success, $failed];
    }

    /**
     * Override parent find method to prevent misuse
     * ProductBadge table requires composite key lookup
     * 
     * @param mixed $id
     * @return ProductBadge|array|null
     */
    public function find($id = null)
    {
        if ($id !== null) {
            log_message('warning', 'ProductBadgeModel::find() called with single ID. Use findByCompositeKey() instead.');
        }
        
        return parent::find($id);
    }

    /**
     * Override save to handle composite key uniqueness
     * 
     * @param array|object $data
     * @return bool
     */
    public function save($data): bool
    {
        // Convert to array if object
        if (is_object($data)) {
            $data = (array) $data;
        }
        
        // Check for composite key
        if (isset($data['product_id']) && isset($data['badge_id'])) {
            // Check if relationship already exists
            $existing = $this->findByCompositeKey($data['product_id'], $data['badge_id']);
            if ($existing) {
                // Update existing (though typically we don't update junction tables)
                return $this->update($existing->id, $data);
            }
        }
        
        return parent::save($data);
    }

    /**
     * Custom validation for composite key uniqueness
     * 
     * @param int $product_id
     * @param int $badge_id
     * @return bool
     */
    public function validateUniqueAssignment(int $product_id, int $badge_id): bool
    {
        $count = $this->where('product_id', $product_id)
                      ->where('badge_id', $badge_id)
                      ->countAllResults();
        
        return $count === 0;
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/AdminModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\Admin;
use CodeIgniter\Exceptions\ModelException;
use Exception;

/**
 * Admin Model
 * 
 * Handles admin authentication, authorization, and management.
 * Core security model with brute force protection and audit logging.
 * 
 * @package App\Models
 */
class AdminModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'admins';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Return type
     * 
     * @var string
     */
    protected $returnType = Admin::class;

    /**
     * Allowed fields for mass assignment
     * Note: password_hash should only be set via setPassword() method
     * 
     * @var array
     */
    protected $allowedFields = [
        'username',
        'email',
        'name',
        'role',
        'active',
        'last_login',
        'login_attempts',
        'password_hash' // Only for updates via changePassword()
    ];

    /**
     * Validation rules for insert
     * 
     * @var array
     */
    protected $validationRules = [
        'username' => 'required|alpha_numeric_space|min_length[3]|max_length[50]|is_unique[admins.username,id,{id}]',
        'email'    => 'required|valid_email|max_length[100]|is_unique[admins.email,id,{id}]',
        'name'     => 'required|string|max_length[100]',
        'role'     => 'required|in_list[admin,super_admin]',
        'active'   => 'required|in_list[0,1]',
        'password' => 'permit_empty|min_length[8]' // Only for validation, not saved
    ];

    /**
     * Validation messages
     * 
     * @var array
     */
    protected $validationMessages = [
        'username' => [
            'is_unique' => 'This username is already taken.',
            'required'  => 'Username is required.'
        ],
        'email' => [
            'valid_email' => 'Please provide a valid email address.',
            'is_unique'   => 'This email is already registered.'
        ],
        'role' => [
            'in_list' => 'Role must be either admin or super_admin.'
        ]
    ];

    /**
     * Maximum login attempts before lockout
     * 
     * @var int
     */
    public const MAX_LOGIN_ATTEMPTS = 5;

    /**
     * Lockout duration in minutes
     * 
     * @var int
     */
    public const LOCKOUT_DURATION = 15;

    /**
     * Password hash options (bcrypt)
     * 
     * @var array
     */
    public const PASSWORD_OPTIONS = [
        'cost' => 12 // Higher cost = more secure but slower
    ];

    /**
     * Before insert callback
     * 
     * @param array $data
     * @return array
     */
    protected function beforeInsert(array $data): array
    {
        // Set default active status if not provided
        if (!isset($data['active'])) {
            $data['active'] = 1;
        }

        // Set default role if not provided
        if (!isset($data['role'])) {
            $data['role'] = 'admin';
        }

        // Set timestamps
        $data['created_at'] = date('Y-m-d H:i:s');
        $data['updated_at'] = date('Y-m-d H:i:s');

        return $data;
    }

    /**
     * Before update callback
     * 
     * @param array $data
     * @return array
     */
    protected function beforeUpdate(array $data): array
    {
        $data['updated_at'] = date('Y-m-d H:i:s');
        return $data;
    }

    /**
     * Authenticate admin by credentials
     * 
     * @param string $identifier Username or email
     * @param string $password Plain text password
     * @param string $ipAddress Client IP for logging
     * @return Admin|false Returns Admin entity on success, false on failure
     */
    public function authenticate(string $identifier, string $password, string $ipAddress)
    {
        // Find admin by username or email
        $admin = $this->where('username', $identifier)
                      ->orWhere('email', $identifier)
                      ->first();

        if (!$admin) {
            log_message('info', "Failed login attempt for identifier '{$identifier}' from IP {$ipAddress}: User not found");
            return false;
        }

        // Check if account is active
        if (!$admin->active) {
            log_message('warning', "Inactive admin account login attempt: {$admin->username} (ID: {$admin->id})");
            return false;
        }

        // Check if account is locked
        if ($this->isAccountLocked($admin)) {
            log_message('warning', "Locked admin account login attempt: {$admin->username} (ID: {$admin->id})");
            return false;
        }

        // Verify password
        if (!$this->verifyPassword($password, $admin->password_hash)) {
            // Increment login attempts
            $this->incrementLoginAttempts($admin->id);
            
            log_message('info', "Failed password for admin: {$admin->username} (ID: {$admin->id}) from IP {$ipAddress}");
            return false;
        }

        // Reset login attempts on successful login
        $this->resetLoginAttempts($admin->id);
        
        // Update last login
        $this->updateLastLogin($admin->id);
        
        log_message('info', "Successful login for admin: {$admin->username} (ID: {$admin->id}) from IP {$ipAddress}");
        
        return $admin;
    }

    /**
     * Verify password against hash
     * 
     * @param string $password Plain text password
     * @param string $hash Password hash
     * @return bool
     */
    public function verifyPassword(string $password, string $hash): bool
    {
        return password_verify($password, $hash);
    }

    /**
     * Create password hash
     * 
     * @param string $password Plain text password
     * @return string Hashed password
     */
    public function hashPassword(string $password): string
    {
        return password_hash($password, PASSWORD_BCRYPT, self::PASSWORD_OPTIONS);
    }

    /**
     * Check if password needs rehash
     * 
     * @param string $hash Current password hash
     * @return bool
     */
    public function passwordNeedsRehash(string $hash): bool
    {
        return password_needs_rehash($hash, PASSWORD_BCRYPT, self::PASSWORD_OPTIONS);
    }

    /**
     * Update admin password
     * 
     * @param int $adminId
     * @param string $newPassword
     * @return bool
     */
    public function updatePassword(int $adminId, string $newPassword): bool
    {
        $hash = $this->hashPassword($newPassword);
        
        return $this->update($adminId, [
            'password_hash' => $hash,
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Increment login attempts
     * 
     * @param int $adminId
     * @return bool
     */
    public function incrementLoginAttempts(int $adminId): bool
    {
        $admin = $this->find($adminId);
        if (!$admin) {
            return false;
        }

        $attempts = $admin->login_attempts + 1;
        
        return $this->update($adminId, [
            'login_attempts' => $attempts,
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Reset login attempts
     * 
     * @param int $adminId
     * @return bool
     */
    public function resetLoginAttempts(int $adminId): bool
    {
        return $this->update($adminId, [
            'login_attempts' => 0,
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Update last login timestamp
     * 
     * @param int $adminId
     * @return bool
     */
    public function updateLastLogin(int $adminId): bool
    {
        return $this->update($adminId, [
            'last_login' => date('Y-m-d H:i:s'),
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Check if account is locked due to too many login attempts
     * 
     * @param Admin $admin
     * @return bool
     */
    public function isAccountLocked(Admin $admin): bool
    {
        if ($admin->login_attempts < self::MAX_LOGIN_ATTEMPTS) {
            return false;
        }

        // Check if lockout duration has passed
        if ($admin->last_login) {
            $lastAttempt = strtotime($admin->updated_at);
            $lockoutUntil = $lastAttempt + (self::LOCKOUT_DURATION * 60);
            
            if (time() > $lockoutUntil) {
                // Lockout period expired, reset attempts
                $this->resetLoginAttempts($admin->id);
                return false;
            }
        }

        return true;
    }

    /**
     * Get lockout time remaining in minutes
     * 
     * @param Admin $admin
     * @return int|null Minutes remaining, null if not locked
     */
    public function getLockoutRemaining(Admin $admin): ?int
    {
        if ($admin->login_attempts < self::MAX_LOGIN_ATTEMPTS) {
            return null;
        }

        if (!$admin->updated_at) {
            return null;
        }

        $lastAttempt = strtotime($admin->updated_at);
        $lockoutUntil = $lastAttempt + (self::LOCKOUT_DURATION * 60);
        $remaining = ceil(($lockoutUntil - time()) / 60);

        return max(0, (int) $remaining);
    }

    /**
     * Find admin by username
     * 
     * @param string $username
     * @return Admin|null
     */
    public function findByUsername(string $username): ?Admin
    {
        return $this->where('username', $username)->first();
    }

    /**
     * Find admin by email
     * 
     * @param string $email
     * @return Admin|null
     */
    public function findByEmail(string $email): ?Admin
    {
        return $this->where('email', $email)->first();
    }

    /**
     * Find all active admins
     * 
     * @return array
     */
    public function findAllActive(): array
    {
        return $this->where('active', 1)
                    ->where('deleted_at', null)
                    ->orderBy('name', 'ASC')
                    ->findAll();
    }

    /**
     * Find all super admins
     * 
     * @return array
     */
    public function findSuperAdmins(): array
    {
        return $this->where('role', 'super_admin')
                    ->where('active', 1)
                    ->where('deleted_at', null)
                    ->findAll();
    }

    /**
     * Activate admin account
     * 
     * @param int $adminId
     * @return bool
     */
    public function activate(int $adminId): bool
    {
        return $this->update($adminId, [
            'active' => 1,
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Deactivate admin account
     * 
     * @param int $adminId
     * @return bool
     */
    public function deactivate(int $adminId): bool
    {
        return $this->update($adminId, [
            'active' => 0,
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Promote admin to super admin
     * 
     * @param int $adminId
     * @return bool
     */
    public function promoteToSuperAdmin(int $adminId): bool
    {
        return $this->update($adminId, [
            'role' => 'super_admin',
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Demote super admin to admin
     * 
     * @param int $adminId
     * @return bool
     */
    public function demoteToAdmin(int $adminId): bool
    {
        return $this->update($adminId, [
            'role' => 'admin',
            'updated_at' => date('Y-m-d H:i:s')
        ]);
    }

    /**
     * Check if admin can be deleted (business rules)
     * 
     * @param int $adminId
     * @return array [bool $canDelete, string $reason]
     */
    public function canDelete(int $adminId): array
    {
        $admin = $this->find($adminId);
        if (!$admin) {
            return [false, 'Admin not found'];
        }

        // Cannot delete self
        if ($adminId == session('admin_id')) {
            return [false, 'Cannot delete your own account'];
        }

        // Check if admin is a super admin
        if ($admin->role === 'super_admin') {
            // Check if this is the last super admin
            $superAdmins = $this->findSuperAdmins();
            if (count($superAdmins) <= 1) {
                return [false, 'Cannot delete the last super admin'];
            }
        }

        // Check if admin has verified products (foreign key constraint)
        // This would require a check in products table
        // For now, we'll assume it's okay

        return [true, ''];
    }

    /**
     * Create new admin with password
     * 
     * @param array $data Admin data including 'password'
     * @return int|false Insert ID or false on failure
     */
    public function createAdmin(array $data)
    {
        $this->db->transStart();

        try {
            // Hash password if provided
            if (isset($data['password']) && !empty($data['password'])) {
                $data['password_hash'] = $this->hashPassword($data['password']);
                unset($data['password']);
            }

            // Insert admin
            $adminId = $this->insert($data, true); // Return ID

            $this->db->transComplete();

            if ($this->db->transStatus() === false) {
                log_message('error', 'Failed to create admin: ' . json_encode($data));
                return false;
            }

            log_message('info', "Admin created: {$data['username']} (ID: {$adminId})");
            return $adminId;

        } catch (Exception $e) {
            $this->db->transRollback();
            log_message('error', 'Admin creation failed: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Update admin profile (excluding password)
     * 
     * @param int $adminId
     * @param array $data
     * @return bool
     */
    public function updateProfile(int $adminId, array $data): bool
    {
        // Remove password fields if present
        unset($data['password'], $data['password_hash']);

        return $this->update($adminId, $data);
    }

    /**
     * Count total admins
     * 
     * @return int
     */
    public function countTotal(): int
    {
        return $this->where('deleted_at', null)->countAllResults();
    }

    /**
     * Count active admins
     * 
     * @return int
     */
    public function countActive(): int
    {
        return $this->where('active', 1)
                    ->where('deleted_at', null)
                    ->countAllResults();
    }

    /**
     * Get admin statistics for dashboard
     * 
     * @return array
     */
    public function getDashboardStats(): array
    {
        $cacheKey = $this->cacheKey('dashboard_stats');
        
        return $this->cached($cacheKey, function() {
            $stats = [
                'total_admins' => $this->countTotal(),
                'active_admins' => $this->countActive(),
                'super_admins' => $this->where('role', 'super_admin')
                                      ->where('deleted_at', null)
                                      ->countAllResults(),
                'recent_logins' => $this->where('last_login >=', date('Y-m-d H:i:s', strtotime('-7 days')))
                                       ->where('deleted_at', null)
                                       ->countAllResults(),
            ];

            return $stats;
        }, 300); // 5 minutes cache
    }

    /**
     * Search admins with filters
     * 
     * @param array $filters [search, role, active]
     * @param int $limit
     * @param int $offset
     * @return array
     */
    public function searchAdmins(array $filters = [], int $limit = 50, int $offset = 0): array
    {
        $builder = $this->builder();

        // Apply filters
        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $builder->groupStart()
                    ->like('username', $search)
                    ->orLike('email', $search)
                    ->orLike('name', $search)
                    ->groupEnd();
        }

        if (isset($filters['role']) && in_array($filters['role'], ['admin', 'super_admin'])) {
            $builder->where('role', $filters['role']);
        }

        if (isset($filters['active'])) {
            $builder->where('active', (int) $filters['active']);
        }

        // Exclude deleted
        $builder->where('deleted_at', null);

        // Count total for pagination
        $total = $builder->countAllResults(false);

        // Get results
        $results = $builder->orderBy('name', 'ASC')
                          ->limit($limit, $offset)
                          ->get()
                          ->getResult($this->returnType);

        return [
            'total' => $total,
            'results' => $results,
            'limit' => $limit,
            'offset' => $offset
        ];
    }

    /**
     * Override delete to prevent deleting certain admins
     * 
     * @param mixed $id
     * @param bool $purge
     * @return bool
     */
    public function delete($id = null, bool $purge = false)
    {
        if ($id !== null) {
            [$canDelete, $reason] = $this->canDelete($id);
            
            if (!$canDelete) {
                throw new ModelException("Cannot delete admin: {$reason}");
            }
        }

        return parent::delete($id, $purge);
    }

    /**
     * Generate a secure random password
     * 
     * @param int $length
     * @return string
     */
    public function generateRandomPassword(int $length = 12): string
    {
        $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_-=+';
        $password = '';
        
        for ($i = 0; $i < $length; $i++) {
            $password .= $chars[random_int(0, strlen($chars) - 1)];
        }
        
        return $password;
    }

    /**
     * Validate admin data for update
     * 
     * @param array $data
     * @param int $adminId
     * @return array [bool $valid, array $errors]
     */
    public function validateAdminData(array $data, int $adminId): array
    {
        // Remove password from validation if present
        unset($data['password']);
        
        // Temporarily set the ID for unique validation
        if (isset($data['username']) || isset($data['email'])) {
            $this->validationRules['username'] = "required|alpha_numeric_space|min_length[3]|max_length[50]|is_unique[admins.username,id,{$adminId}]";
            $this->validationRules['email'] = "required|valid_email|max_length[100]|is_unique[admins.email,id,{$adminId}]";
        }
        
        return $this->validateData($data);
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ MODELS: app/Models/AuditLogModel.php
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<?php

namespace App\Models;

use App\Entities\AuditLog;
use CodeIgniter\I18n\Time;

/**
 * Audit Log Model
 * 
 * Tracks all administrative actions for security auditing and accountability.
 * Immutable log - entries cannot be modified or deleted (read-only).
 * 
 * @package App\Models
 */
class AuditLogModel extends BaseModel
{
    /**
     * Table name
     * 
     * @var string
     */
    protected $table = 'admin_actions';

    /**
     * Primary key
     * 
     * @var string
     */
    protected $primaryKey = 'id';

    /**
     * Return type
     * 
     * @var string
     */
    protected $returnType = AuditLog::class;

    /**
     * Allowed fields for insertion only
     * This model is write-once, read-many
     * 
     * @var array
     */
    protected $allowedFields = [
        'admin_id',
        'action_type',
        'entity_type',
        'entity_id',
        'old_values',
        'new_values',
        'changes_summary',
        'ip_address',
        'user_agent'
    ];

    /**
     * Use timestamps? NO - uses performed_at instead
     * 
     * @var bool
     */
    protected $useTimestamps = false;

    /**
     * Use soft deletes? NO - audit logs are immutable
     * 
     * @var bool
     */
    protected $useSoftDeletes = false;

    /**
     * Default ordering for queries
     * 
     * @var string
     */
    protected $orderBy = 'performed_at DESC';

    /**
     * Action types constants
     * 
     * @var array
     */
    public const ACTION_TYPES = [
        'create'              => 'Create',
        'update'              => 'Update',
        'delete'              => 'Delete',
        'verify'              => 'Verify',
        'publish'             => 'Publish',
        'archive'             => 'Archive',
        'restore'             => 'Restore',
        'login'               => 'Login',
        'logout'              => 'Logout',
        'password_change'     => 'Password Change',
        'role_change'         => 'Role Change',
        'status_change'       => 'Status Change',
        'bulk_operation'      => 'Bulk Operation',
        'import'              => 'Import',
        'export'              => 'Export',
        'system'              => 'System Action'
    ];

    /**
     * Entity types from database
     * 
     * @var array
     */
    public const ENTITY_TYPES = [
        'Product',
        'Category',
        'Marketplace',
        'Badge',
        'MarketplaceBadge',
        'Link',
        'Admin',
        'ProductBadge'
    ];

    /**
     * Before insert callback
     * Sets performed_at timestamp and validates data
     * 
     * @param array $data
     * @return array
     */
    protected function beforeInsert(array $data): array
    {
        // Set performed_at to current time if not provided
        if (!isset($data['performed_at']) || empty($data['performed_at'])) {
            $data['performed_at'] = date('Y-m-d H:i:s');
        }

        // Validate JSON fields
        if (isset($data['old_values']) && is_array($data['old_values'])) {
            $data['old_values'] = json_encode($data['old_values'], JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        }

        if (isset($data['new_values']) && is_array($data['new_values'])) {
            $data['new_values'] = json_encode($data['new_values'], JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
        }

        // Truncate changes_summary if too long
        if (isset($data['changes_summary']) && strlen($data['changes_summary']) > 500) {
            $data['changes_summary'] = substr($data['changes_summary'], 0, 497) . '...';
        }

        return $data;
    }

    /**
     * Log an administrative action
     * 
     * @param array $logData
     * @return int|false Insert ID or false on failure
     */
    public function logAction(array $logData)
    {
        // Required fields validation
        $required = ['action_type', 'entity_type', 'entity_id'];
        foreach ($required as $field) {
            if (!isset($logData[$field]) || empty($logData[$field])) {
                log_message('error', "Audit log missing required field: {$field}");
                return false;
            }
        }

        // Default admin_id to current session if not provided
        if (!isset($logData['admin_id'])) {
            $logData['admin_id'] = session('admin_id') ?? null;
        }

        // Add IP address if not provided
        if (!isset($logData['ip_address'])) {
            $logData['ip_address'] = service('request')->getIPAddress();
        }

        // Add user agent if not provided
        if (!isset($logData['user_agent'])) {
            $logData['user_agent'] = service('request')->getUserAgent()->getAgentString();
        }

        try {
            $insertId = $this->insert($logData, true); // Return insert ID
            
            if ($insertId) {
                // Clear relevant caches
                $this->clearAuditCache($logData);
                
                // Log to file for additional backup
                $this->logToFile($insertId, $logData);
            }
            
            return $insertId;
            
        } catch (\Exception $e) {
            log_message('error', 'Failed to log audit action: ' . $e->getMessage());
            
            // Emergency fallback: log to file only
            $this->logToFile(0, $logData, 'FAILED_DB: ' . $e->getMessage());
            
            return false;
        }
    }

    /**
     * Log a CRUD operation with before/after states
     * 
     * @param string $action      create|update|delete
     * @param string $entityType  Entity class name
     * @param int $entityId       Entity ID
     * @param mixed $oldEntity    Old entity state (for update/delete)
     * @param mixed $newEntity    New entity state (for create/update)
     * @param int|null $adminId   Admin ID (defaults to session)
     * @return int|false
     */
    public function logCrudOperation(
        string $action,
        string $entityType,
        int $entityId,
        $oldEntity = null,
        $newEntity = null,
        ?int $adminId = null
    ) {
        $logData = [
            'admin_id'    => $adminId ?? session('admin_id'),
            'action_type' => $action,
            'entity_type' => $entityType,
            'entity_id'   => $entityId,
        ];

        // Prepare old and new values
        if ($oldEntity !== null) {
            $logData['old_values'] = $this->prepareEntityData($oldEntity);
        }

        if ($newEntity !== null) {
            $logData['new_values'] = $this->prepareEntityData($newEntity);
        }

        // Generate changes summary
        $logData['changes_summary'] = $this->generateChangesSummary(
            $action,
            $entityType,
            $entityId,
            $logData['old_values'] ?? null,
            $logData['new_values'] ?? null
        );

        return $this->logAction($logData);
    }

    /**
     * Log a state transition (e.g., draft â†’ pending_verification)
     * 
     * @param string $entityType
     * @param int $entityId
     * @param string $fromState
     * @param string $toState
     * @param int|null $adminId
     * @return int|false
     */
    public function logStateTransition(
        string $entityType,
        int $entityId,
        string $fromState,
        string $toState,
        ?int $adminId = null
    ) {
        $logData = [
            'admin_id'    => $adminId ?? session('admin_id'),
            'action_type' => 'status_change',
            'entity_type' => $entityType,
            'entity_id'   => $entityId,
            'old_values'  => ['status' => $fromState],
            'new_values'  => ['status' => $toState],
            'changes_summary' => "Status changed from '{$fromState}' to '{$toState}'"
        ];

        return $this->logAction($logData);
    }

    /**
     * Log admin login
     * 
     * @param int $adminId
     * @param bool $success
     * @param string|null $reason Failure reason if unsuccessful
     * @return int|false
     */
    public function logLogin(int $adminId, bool $success = true, ?string $reason = null)
    {
        $logData = [
            'admin_id'    => $adminId,
            'action_type' => 'login',
            'entity_type' => 'Admin',
            'entity_id'   => $adminId,
            'new_values'  => [
                'success' => $success,
                'timestamp' => date('Y-m-d H:i:s'),
                'ip_address' => service('request')->getIPAddress()
            ],
            'changes_summary' => $success 
                ? 'Successful login' 
                : 'Failed login attempt' . ($reason ? ': ' . $reason : '')
        ];

        return $this->logAction($logData);
    }

    /**
     * Log admin logout
     * 
     * @param int $adminId
     * @return int|false
     */
    public function logLogout(int $adminId)
    {
        $logData = [
            'admin_id'    => $adminId,
            'action_type' => 'logout',
            'entity_type' => 'Admin',
            'entity_id'   => $adminId,
            'changes_summary' => 'Admin logged out'
        ];

        return $this->logAction($logData);
    }

    /**
     * Get logs for specific entity
     * 
     * @param string $entityType
     * @param int $entityId
     * @param int $limit
     * @param int $offset
     * @return array
     */
    public function getEntityLogs(string $entityType, int $entityId, int $limit = 50, int $offset = 0): array
    {
        $cacheKey = $this->cacheKey("entity_{$entityType}_{$entityId}_{$limit}_{$offset}");
        
        return $this->cached($cacheKey, function() use ($entityType, $entityId, $limit, $offset) {
            return $this->where('entity_type', $entityType)
                        ->where('entity_id', $entityId)
                        ->orderBy('performed_at', 'DESC')
                        ->limit($limit, $offset)
                        ->findAll();
        });
    }

    /**
     * Get logs for specific admin
     * 
     * @param int $adminId
     * @param int $limit
     * @param int $offset
     * @return array
     */
    public function getAdminLogs(int $adminId, int $limit = 50, int $offset = 0): array
    {
        $cacheKey = $this->cacheKey("admin_{$adminId}_{$limit}_{$offset}");
        
        return $this->cached($cacheKey, function() use ($adminId, $limit, $offset) {
            return $this->where('admin_id', $adminId)
                        ->orderBy('performed_at', 'DESC')
                        ->limit($limit, $offset)
                        ->findAll();
        });
    }

    /**
     * Search logs with multiple filters
     * 
     * @param array $filters
     * @param int $limit
     * @param int $offset
     * @return array [total, results]
     */
    public function searchLogs(array $filters = [], int $limit = 50, int $offset = 0): array
    {
        $builder = $this->builder();
        
        // Apply filters
        if (!empty($filters['admin_id'])) {
            $builder->where('admin_id', (int) $filters['admin_id']);
        }
        
        if (!empty($filters['action_type'])) {
            $builder->where('action_type', $filters['action_type']);
        }
        
        if (!empty($filters['entity_type'])) {
            $builder->where('entity_type', $filters['entity_type']);
        }
        
        if (!empty($filters['entity_id'])) {
            $builder->where('entity_id', (int) $filters['entity_id']);
        }
        
        if (!empty($filters['date_from'])) {
            $builder->where('performed_at >=', $filters['date_from']);
        }
        
        if (!empty($filters['date_to'])) {
            $builder->where('performed_at <=', $filters['date_to'] . ' 23:59:59');
        }
        
        if (!empty($filters['search'])) {
            $search = $filters['search'];
            $builder->groupStart()
                    ->like('changes_summary', $search)
                    ->orLike('ip_address', $search)
                    ->groupEnd();
        }
        
        // Count total
        $total = $builder->countAllResults(false);
        
        // Get results
        $results = $builder->orderBy('performed_at', 'DESC')
                          ->limit($limit, $offset)
                          ->get()
                          ->getResult($this->returnType);
        
        return [
            'total' => $total,
            'results' => $results,
            'limit' => $limit,
            'offset' => $offset
        ];
    }

    /**
     * Get recent activity for dashboard
     * 
     * @param int $limit
     * @return array
     */
    public function getRecentActivity(int $limit = 20): array
    {
        $cacheKey = $this->cacheKey("recent_{$limit}_" . date('YmdH'));
        
        return $this->cached($cacheKey, function() use ($limit) {
            return $this->orderBy('performed_at', 'DESC')
                        ->limit($limit)
                        ->findAll();
        });
    }

    /**
     * Get statistics for reporting
     * 
     * @param string $period day|week|month|year
     * @return array
     */
    public function getStatistics(string $period = 'month'): array
    {
        $cacheKey = $this->cacheKey("stats_{$period}_" . date('Ymd'));
        
        return $this->cached($cacheKey, function() use ($period) {
            $dateCondition = $this->getDateCondition($period);
            
            $stats = [
                'total_actions' => 0,
                'actions_by_type' => [],
                'actions_by_entity' => [],
                'top_admins' => [],
                'activity_trend' => []
            ];
            
            // Total actions
            $stats['total_actions'] = $this->where($dateCondition)->countAllResults();
            
            // Actions by type
            $builder = $this->builder();
            $query = $builder->select('action_type, COUNT(*) as count')
                            ->where($dateCondition)
                            ->groupBy('action_type')
                            ->orderBy('count', 'DESC')
                            ->get();
            $stats['actions_by_type'] = $query->getResultArray();
            
            // Actions by entity
            $builder = $this->builder();
            $query = $builder->select('entity_type, COUNT(*) as count')
                            ->where($dateCondition)
                            ->groupBy('entity_type')
                            ->orderBy('count', 'DESC')
                            ->get();
            $stats['actions_by_entity'] = $query->getResultArray();
            
            // Top admins
            $builder = $this->builder();
            $query = $builder->select('admin_id, COUNT(*) as count')
                            ->where($dateCondition)
                            ->where('admin_id IS NOT NULL')
                            ->groupBy('admin_id')
                            ->orderBy('count', 'DESC')
                            ->limit(10)
                            ->get();
            $stats['top_admins'] = $query->getResultArray();
            
            return $stats;
        }, 300); // 5 minutes cache
    }

    /**
     * Clean up old logs (archival function)
     * 
     * @param int $daysOld Keep logs newer than X days
     * @return int Number of rows affected
     */
    public function cleanupOldLogs(int $daysOld = 365): int
    {
        $dateLimit = date('Y-m-d H:i:s', strtotime("-{$daysOld} days"));
        
        // For MVP: we don't delete, we archive to separate table
        // For now, just return count of old logs
        $count = $this->where('performed_at <', $dateLimit)->countAllResults();
        
        log_message('info', "Found {$count} audit logs older than {$daysOld} days");
        
        // In production, you might:
        // 1. Export to archive table
        // 2. Compress and store off-site
        // 3. Then delete from main table
        
        return $count;
    }

    /**
     * Export logs to CSV
     * 
     * @param array $filters
     * @return string CSV content
     */
    public function exportToCsv(array $filters = []): string
    {
        $logs = $this->searchLogs($filters, 10000, 0)['results'];
        
        $csv = "ID,Date,Time,Admin ID,Action Type,Entity Type,Entity ID,Changes Summary,IP Address\n";
        
        foreach ($logs as $log) {
            $date = $log->performed_at ? date('Y-m-d', strtotime($log->performed_at)) : '';
            $time = $log->performed_at ? date('H:i:s', strtotime($log->performed_at)) : '';
            
            $csv .= sprintf(
                '%d,%s,%s,%s,%s,%s,%d,"%s",%s' . "\n",
                $log->id,
                $date,
                $time,
                $log->admin_id ?? 'SYSTEM',
                $log->action_type,
                $log->entity_type,
                $log->entity_id,
                str_replace('"', '""', $log->changes_summary ?? ''),
                $log->ip_address
            );
        }
        
        return $csv;
    }

    /**
     * Prepare entity data for JSON storage
     * 
     * @param mixed $entity
     * @return array
     */
    private function prepareEntityData($entity): array
    {
        if (is_object($entity) && method_exists($entity, 'toArray')) {
            return $entity->toArray();
        }
        
        if (is_array($entity)) {
            return $entity;
        }
        
        if (is_object($entity)) {
            return (array) $entity;
        }
        
        return ['raw' => $entity];
    }

    /**
     * Generate human-readable changes summary
     * 
     * @param string $action
     * @param string $entityType
     * @param int $entityId
     * @param mixed $oldValues
     * @param mixed $newValues
     * @return string
     */
    private function generateChangesSummary(
        string $action,
        string $entityType,
        int $entityId,
        $oldValues = null,
        $newValues = null
    ): string {
        $oldArray = is_string($oldValues) ? json_decode($oldValues, true) : $oldValues;
        $newArray = is_string($newValues) ? json_decode($newValues, true) : $newValues;
        
        switch ($action) {
            case 'create':
                return "Created {$entityType} #{$entityId}";
                
            case 'update':
                if (is_array($oldArray) && is_array($newArray)) {
                    $changes = [];
                    foreach ($newArray as $key => $value) {
                        if (!isset($oldArray[$key]) || $oldArray[$key] != $value) {
                            $oldVal = $oldArray[$key] ?? '(empty)';
                            $newVal = $value;
                            
                            // Truncate long values
                            if (is_string($oldVal) && strlen($oldVal) > 30) {
                                $oldVal = substr($oldVal, 0, 27) . '...';
                            }
                            if (is_string($newVal) && strlen($newVal) > 30) {
                                $newVal = substr($newVal, 0, 27) . '...';
                            }
                            
                            $changes[] = "{$key}: {$oldVal} â†’ {$newVal}";
                        }
                    }
                    
                    if (empty($changes)) {
                        return "Updated {$entityType} #{$entityId} (no visible changes)";
                    }
                    
                    return "Updated {$entityType} #{$entityId}: " . implode(', ', array_slice($changes, 0, 3)) . 
                           (count($changes) > 3 ? '...' : '');
                }
                return "Updated {$entityType} #{$entityId}";
                
            case 'delete':
                return "Deleted {$entityType} #{$entityId}";
                
            default:
                return ucfirst($action) . " {$entityType} #{$entityId}";
        }
    }

    /**
     * Get date condition for period
     * 
     * @param string $period
     * @return string
     */
    private function getDateCondition(string $period): string
    {
        $formats = [
            'day'   => 'Y-m-d',
            'week'  => 'Y-m-d',
            'month' => 'Y-m',
            'year'  => 'Y'
        ];
        
        if (!isset($formats[$period])) {
            $period = 'month';
        }
        
        $date = date($formats[$period]);
        
        switch ($period) {
            case 'day':
                return "DATE(performed_at) = '{$date}'";
            case 'week':
                $monday = date('Y-m-d', strtotime('monday this week'));
                $sunday = date('Y-m-d', strtotime('sunday this week'));
                return "DATE(performed_at) BETWEEN '{$monday}' AND '{$sunday}'";
            case 'month':
                return "DATE_FORMAT(performed_at, '%Y-%m') = '{$date}'";
            case 'year':
                return "YEAR(performed_at) = '{$date}'";
            default:
                return "1=1";
        }
    }

    /**
     * Log to file as backup
     * 
     * @param int $logId
     * @param array $data
     * @param string $note
     * @return void
     */
    private function logToFile(int $logId, array $data, string $note = ''): void
    {
        $logMessage = sprintf(
            "[%s] Audit Log %s: %s | Admin: %s | Action: %s | Entity: %s #%s | IP: %s | %s\n",
            date('Y-m-d H:i:s'),
            $logId ? '#' . $logId : 'FAILED',
            $data['changes_summary'] ?? 'No summary',
            $data['admin_id'] ?? 'SYSTEM',
            $data['action_type'] ?? 'unknown',
            $data['entity_type'] ?? 'unknown',
            $data['entity_id'] ?? '0',
            $data['ip_address'] ?? '0.0.0.0',
            $note
        );
        
        // Write to audit log file
        $logPath = WRITEPATH . 'logs/audit-' . date('Y-m-d') . '.log';
        file_put_contents($logPath, $logMessage, FILE_APPEND | LOCK_EX);
    }

    /**
     * Clear relevant audit caches
     * 
     * @param array $logData
     * @return void
     */
    private function clearAuditCache(array $logData): void
    {
        // Clear recent activity cache
        $this->clearCache($this->cacheKey('recent_*'));
        
        // Clear entity-specific caches
        if (isset($logData['entity_type']) && isset($logData['entity_id'])) {
            $this->clearCache($this->cacheKey("entity_{$logData['entity_type']}_{$logData['entity_id']}_*"));
        }
        
        // Clear admin-specific caches
        if (isset($logData['admin_id'])) {
            $this->clearCache($this->cacheKey("admin_{$logData['admin_id']}_*"));
        }
        
        // Clear statistics caches
        $this->clearCache($this->cacheKey('stats_*'));
    }

    /**
     * Override delete method - audit logs are immutable
     * 
     * @param mixed $id
     * @param bool $purge
     * @return never
     * @throws \RuntimeException
     */
    public function delete($id = null, bool $purge = false)
    {
        throw new \RuntimeException('Audit logs cannot be deleted. They are immutable for security reasons.');
    }

    /**
     * Override update method - audit logs are immutable
     * 
     * @param mixed $id
     * @param array $data
     * @return never
     * @throws \RuntimeException
     */
    public function update($id = null, $data = null): bool
    {
        throw new \RuntimeException('Audit logs cannot be updated. They are immutable for security reasons.');
    }

    /**
     * Check if action type is valid
     * 
     * @param string $actionType
     * @return bool
     */
    public function isValidActionType(string $actionType): bool
    {
        return array_key_exists($actionType, self::ACTION_TYPES);
    }

    /**
     * Check if entity type is valid
     * 
     * @param string $entityType
     * @return bool
     */
    public function isValidEntityType(string $entityType): bool
    {
        return in_array($entityType, self::ENTITY_TYPES);
    }
}
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

